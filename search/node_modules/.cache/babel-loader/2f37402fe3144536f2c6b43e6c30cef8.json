{"ast":null,"code":"import PropTypes from 'prop-types';\nimport React, { useEffect } from 'react';\nimport { useRecordingState, useCachedSection } from './cacheable-section-state';\nimport { useOfflineInterface } from './offline-interface';\nconst recordingStates = {\n  default: 'default',\n  pending: 'pending',\n  recording: 'recording',\n  error: 'error'\n};\n/**\n * Returns the main controls for a cacheable section and manages recording\n * state, which affects the render state of the CacheableSection component.\n * Also returns the cached status of the section, which come straight from\n * the `useCachedSection` hook.\n *\n * @param {String} id\n * @returns {Object}\n */\n\nexport function useCacheableSection(id) {\n  const offlineInterface = useOfflineInterface();\n  const {\n    isCached,\n    lastUpdated,\n    remove,\n    syncCachedSections\n  } = useCachedSection(id);\n  const {\n    recordingState,\n    setRecordingState,\n    removeRecordingState\n  } = useRecordingState(id);\n  useEffect(() => {\n    // On mount, add recording state for this ID to context if needed\n    if (!recordingState) {\n      setRecordingState(recordingStates.default);\n    } // On unnmount, remove recording state if not recording\n\n\n    return () => {\n      if (recordingState && recordingState !== recordingStates.recording && recordingState !== recordingStates.pending) {\n        removeRecordingState();\n      }\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  function startRecording() {\n    let {\n      recordingTimeoutDelay = 1000,\n      onStarted,\n      onCompleted,\n      onError\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // This promise resolving means that the message to the service worker\n    // to start recording was successful. Waiting for resolution prevents\n    // unnecessarily rerendering the whole component in case of an error\n    return offlineInterface.startRecording({\n      sectionId: id,\n      recordingTimeoutDelay,\n      onStarted: () => {\n        onRecordingStarted();\n        onStarted && onStarted();\n      },\n      onCompleted: () => {\n        onRecordingCompleted();\n        onCompleted && onCompleted();\n      },\n      onError: error => {\n        onRecordingError(error);\n        onError && onError(error);\n      }\n    }).then(() => setRecordingState(recordingStates.pending));\n  }\n\n  function onRecordingStarted() {\n    setRecordingState(recordingStates.recording);\n  }\n\n  function onRecordingCompleted() {\n    setRecordingState(recordingStates.default);\n    syncCachedSections();\n  }\n\n  function onRecordingError(error) {\n    console.error('Error during recording:', error);\n    setRecordingState(recordingStates.error);\n  } // isCached, lastUpdated, remove: _could_ be accessed by useCachedSection,\n  // but provided through this hook for convenience\n\n\n  return {\n    recordingState,\n    startRecording,\n    lastUpdated,\n    isCached,\n    remove\n  };\n}\n/**\n * Used to wrap the relevant component to be recorded and saved offline.\n * Depending on the recording state of the section, this wrapper will\n * render its children, not render its children while recording is pending,\n * or RErerender the chilren to force data fetching to record by the service\n * worker.\n *\n * During recording, a loading mask provided by props is also rendered that is\n * intended to prevent other interaction with the app that might interfere\n * with the recording process.\n */\n\nexport function CacheableSection(_ref) {\n  let {\n    id,\n    loadingMask,\n    children\n  } = _ref;\n  // Accesses recording state that useCacheableSection controls\n  const {\n    recordingState\n  } = useRecordingState(id); // The following causes the component to reload in the event of a recording\n  // error; the state will be cleared next time recording moves to pending.\n  // It fixes a component getting stuck while rendered without data after\n  // failing a recording while offline.\n  // Errors can be handled in the `onError` callback to `startRecording`.\n\n  if (recordingState === recordingStates.error) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n  } // Handling rendering with the following conditions prevents an unncessary\n  // rerender after successful recording\n\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, recordingState === recordingStates.recording && loadingMask, recordingState !== recordingStates.pending && children);\n}\nCacheableSection.propTypes = {\n  id: PropTypes.string.isRequired,\n  children: PropTypes.node,\n  loadingMask: PropTypes.node\n};","map":{"version":3,"names":["PropTypes","React","useEffect","useRecordingState","useCachedSection","useOfflineInterface","recordingStates","default","pending","recording","error","useCacheableSection","id","offlineInterface","isCached","lastUpdated","remove","syncCachedSections","recordingState","setRecordingState","removeRecordingState","startRecording","recordingTimeoutDelay","onStarted","onCompleted","onError","sectionId","onRecordingStarted","onRecordingCompleted","onRecordingError","then","console","CacheableSection","loadingMask","children","createElement","Fragment","propTypes","string","isRequired","node"],"sources":["/home/jake/SRC/landing-page/node_modules/@dhis2/app-runtime/node_modules/@dhis2/app-service-offline/build/es/lib/cacheable-section.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React, { useEffect } from 'react';\nimport { useRecordingState, useCachedSection } from './cacheable-section-state';\nimport { useOfflineInterface } from './offline-interface';\nconst recordingStates = {\n  default: 'default',\n  pending: 'pending',\n  recording: 'recording',\n  error: 'error'\n};\n\n/**\n * Returns the main controls for a cacheable section and manages recording\n * state, which affects the render state of the CacheableSection component.\n * Also returns the cached status of the section, which come straight from\n * the `useCachedSection` hook.\n *\n * @param {String} id\n * @returns {Object}\n */\nexport function useCacheableSection(id) {\n  const offlineInterface = useOfflineInterface();\n  const {\n    isCached,\n    lastUpdated,\n    remove,\n    syncCachedSections\n  } = useCachedSection(id);\n  const {\n    recordingState,\n    setRecordingState,\n    removeRecordingState\n  } = useRecordingState(id);\n  useEffect(() => {\n    // On mount, add recording state for this ID to context if needed\n    if (!recordingState) {\n      setRecordingState(recordingStates.default);\n    } // On unnmount, remove recording state if not recording\n\n\n    return () => {\n      if (recordingState && recordingState !== recordingStates.recording && recordingState !== recordingStates.pending) {\n        removeRecordingState();\n      }\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  function startRecording({\n    recordingTimeoutDelay = 1000,\n    onStarted,\n    onCompleted,\n    onError\n  } = {}) {\n    // This promise resolving means that the message to the service worker\n    // to start recording was successful. Waiting for resolution prevents\n    // unnecessarily rerendering the whole component in case of an error\n    return offlineInterface.startRecording({\n      sectionId: id,\n      recordingTimeoutDelay,\n      onStarted: () => {\n        onRecordingStarted();\n        onStarted && onStarted();\n      },\n      onCompleted: () => {\n        onRecordingCompleted();\n        onCompleted && onCompleted();\n      },\n      onError: error => {\n        onRecordingError(error);\n        onError && onError(error);\n      }\n    }).then(() => setRecordingState(recordingStates.pending));\n  }\n\n  function onRecordingStarted() {\n    setRecordingState(recordingStates.recording);\n  }\n\n  function onRecordingCompleted() {\n    setRecordingState(recordingStates.default);\n    syncCachedSections();\n  }\n\n  function onRecordingError(error) {\n    console.error('Error during recording:', error);\n    setRecordingState(recordingStates.error);\n  } // isCached, lastUpdated, remove: _could_ be accessed by useCachedSection,\n  // but provided through this hook for convenience\n\n\n  return {\n    recordingState,\n    startRecording,\n    lastUpdated,\n    isCached,\n    remove\n  };\n}\n\n/**\n * Used to wrap the relevant component to be recorded and saved offline.\n * Depending on the recording state of the section, this wrapper will\n * render its children, not render its children while recording is pending,\n * or RErerender the chilren to force data fetching to record by the service\n * worker.\n *\n * During recording, a loading mask provided by props is also rendered that is\n * intended to prevent other interaction with the app that might interfere\n * with the recording process.\n */\nexport function CacheableSection({\n  id,\n  loadingMask,\n  children\n}) {\n  // Accesses recording state that useCacheableSection controls\n  const {\n    recordingState\n  } = useRecordingState(id); // The following causes the component to reload in the event of a recording\n  // error; the state will be cleared next time recording moves to pending.\n  // It fixes a component getting stuck while rendered without data after\n  // failing a recording while offline.\n  // Errors can be handled in the `onError` callback to `startRecording`.\n\n  if (recordingState === recordingStates.error) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n  } // Handling rendering with the following conditions prevents an unncessary\n  // rerender after successful recording\n\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, recordingState === recordingStates.recording && loadingMask, recordingState !== recordingStates.pending && children);\n}\nCacheableSection.propTypes = {\n  id: PropTypes.string.isRequired,\n  children: PropTypes.node,\n  loadingMask: PropTypes.node\n};"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,YAAtB;AACA,OAAOC,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,iBAAT,EAA4BC,gBAA5B,QAAoD,2BAApD;AACA,SAASC,mBAAT,QAAoC,qBAApC;AACA,MAAMC,eAAe,GAAG;EACtBC,OAAO,EAAE,SADa;EAEtBC,OAAO,EAAE,SAFa;EAGtBC,SAAS,EAAE,WAHW;EAItBC,KAAK,EAAE;AAJe,CAAxB;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,mBAAT,CAA6BC,EAA7B,EAAiC;EACtC,MAAMC,gBAAgB,GAAGR,mBAAmB,EAA5C;EACA,MAAM;IACJS,QADI;IAEJC,WAFI;IAGJC,MAHI;IAIJC;EAJI,IAKFb,gBAAgB,CAACQ,EAAD,CALpB;EAMA,MAAM;IACJM,cADI;IAEJC,iBAFI;IAGJC;EAHI,IAIFjB,iBAAiB,CAACS,EAAD,CAJrB;EAKAV,SAAS,CAAC,MAAM;IACd;IACA,IAAI,CAACgB,cAAL,EAAqB;MACnBC,iBAAiB,CAACb,eAAe,CAACC,OAAjB,CAAjB;IACD,CAJa,CAIZ;;;IAGF,OAAO,MAAM;MACX,IAAIW,cAAc,IAAIA,cAAc,KAAKZ,eAAe,CAACG,SAArD,IAAkES,cAAc,KAAKZ,eAAe,CAACE,OAAzG,EAAkH;QAChHY,oBAAoB;MACrB;IACF,CAJD;EAKD,CAZQ,EAYN,EAZM,CAAT,CAbsC,CAyB9B;;EAER,SAASC,cAAT,GAKQ;IAAA,IALgB;MACtBC,qBAAqB,GAAG,IADF;MAEtBC,SAFsB;MAGtBC,WAHsB;MAItBC;IAJsB,CAKhB,uEAAJ,EAAI;IACN;IACA;IACA;IACA,OAAOZ,gBAAgB,CAACQ,cAAjB,CAAgC;MACrCK,SAAS,EAAEd,EAD0B;MAErCU,qBAFqC;MAGrCC,SAAS,EAAE,MAAM;QACfI,kBAAkB;QAClBJ,SAAS,IAAIA,SAAS,EAAtB;MACD,CANoC;MAOrCC,WAAW,EAAE,MAAM;QACjBI,oBAAoB;QACpBJ,WAAW,IAAIA,WAAW,EAA1B;MACD,CAVoC;MAWrCC,OAAO,EAAEf,KAAK,IAAI;QAChBmB,gBAAgB,CAACnB,KAAD,CAAhB;QACAe,OAAO,IAAIA,OAAO,CAACf,KAAD,CAAlB;MACD;IAdoC,CAAhC,EAeJoB,IAfI,CAeC,MAAMX,iBAAiB,CAACb,eAAe,CAACE,OAAjB,CAfxB,CAAP;EAgBD;;EAED,SAASmB,kBAAT,GAA8B;IAC5BR,iBAAiB,CAACb,eAAe,CAACG,SAAjB,CAAjB;EACD;;EAED,SAASmB,oBAAT,GAAgC;IAC9BT,iBAAiB,CAACb,eAAe,CAACC,OAAjB,CAAjB;IACAU,kBAAkB;EACnB;;EAED,SAASY,gBAAT,CAA0BnB,KAA1B,EAAiC;IAC/BqB,OAAO,CAACrB,KAAR,CAAc,yBAAd,EAAyCA,KAAzC;IACAS,iBAAiB,CAACb,eAAe,CAACI,KAAjB,CAAjB;EACD,CAlEqC,CAkEpC;EACF;;;EAGA,OAAO;IACLQ,cADK;IAELG,cAFK;IAGLN,WAHK;IAILD,QAJK;IAKLE;EALK,CAAP;AAOD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASgB,gBAAT,OAIJ;EAAA,IAJ8B;IAC/BpB,EAD+B;IAE/BqB,WAF+B;IAG/BC;EAH+B,CAI9B;EACD;EACA,MAAM;IACJhB;EADI,IAEFf,iBAAiB,CAACS,EAAD,CAFrB,CAFC,CAI0B;EAC3B;EACA;EACA;EACA;;EAEA,IAAIM,cAAc,KAAKZ,eAAe,CAACI,KAAvC,EAA8C;IAC5C,OAAO,aAAaT,KAAK,CAACkC,aAAN,CAAoBlC,KAAK,CAACmC,QAA1B,EAAoC,IAApC,EAA0CF,QAA1C,CAApB;EACD,CAZA,CAYC;EACF;;;EAGA,OAAO,aAAajC,KAAK,CAACkC,aAAN,CAAoBlC,KAAK,CAACmC,QAA1B,EAAoC,IAApC,EAA0ClB,cAAc,KAAKZ,eAAe,CAACG,SAAnC,IAAgDwB,WAA1F,EAAuGf,cAAc,KAAKZ,eAAe,CAACE,OAAnC,IAA8C0B,QAArJ,CAApB;AACD;AACDF,gBAAgB,CAACK,SAAjB,GAA6B;EAC3BzB,EAAE,EAAEZ,SAAS,CAACsC,MAAV,CAAiBC,UADM;EAE3BL,QAAQ,EAAElC,SAAS,CAACwC,IAFO;EAG3BP,WAAW,EAAEjC,SAAS,CAACwC;AAHI,CAA7B"},"metadata":{},"sourceType":"module"}