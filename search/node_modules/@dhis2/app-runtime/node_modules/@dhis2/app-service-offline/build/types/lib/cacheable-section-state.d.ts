import PropTypes from 'prop-types';
import React from 'react';
import { GlobalStateStore, RecordingState } from '../types';
interface CachedSectionsById {
    [index: string]: {
        lastUpdated: Date;
    };
}
/**
 * Create a store for Cacheable Section state.
 * Expected to be used in app adapter
 */
export declare function createCacheableSectionStore(): GlobalStateStore;
/**
 * Provides context for a global state context which will track cached
 * sections' status and cacheable sections' recording states, which will
 * determine how that component will render. The provider will be a part of
 * the OfflineProvider.
 */
export declare function CacheableSectionProvider({ children, }: {
    children: React.ReactNode;
}): JSX.Element;
export declare namespace CacheableSectionProvider {
    var propTypes: {
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
    };
}
interface RecordingStateControls {
    recordingState: RecordingState;
    setRecordingState: (newState: RecordingState) => void;
    removeRecordingState: () => void;
}
/**
 * Uses an optimized global state to manage 'recording state' values without
 * unnecessarily rerendering all consuming components
 *
 * @param {String} id - ID of the cacheable section to track
 * @returns {Object} { recordingState: String, setRecordingState: Function, removeRecordingState: Function}
 */
export declare function useRecordingState(id: string): RecordingStateControls;
interface CachedSectionsControls {
    cachedSections: CachedSectionsById;
    removeById: (id: string) => Promise<boolean>;
    syncCachedSections: () => Promise<void>;
}
/**
 * Uses global state to manage an object of cached sections' statuses
 *
 * @returns {Object} { cachedSections: Object, removeSection: Function }
 */
export declare function useCachedSections(): CachedSectionsControls;
interface CachedSectionControls {
    lastUpdated: Date;
    isCached: boolean;
    remove: () => Promise<boolean>;
    syncCachedSections: () => Promise<void>;
}
/**
 * Uses global state to manage the cached status of just one section, which
 * prevents unnecessary rerenders of consuming components
 *
 * @param {String} id
 * @returns {Object} { lastUpdated: Date, remove: Function }
 */
export declare function useCachedSection(id: string): CachedSectionControls;
export {};
