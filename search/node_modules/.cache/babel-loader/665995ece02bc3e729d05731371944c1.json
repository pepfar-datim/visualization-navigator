{"ast":null,"code":"import PropTypes from 'prop-types';\nimport React from 'react';\nimport { createStore, useGlobalState, useGlobalStateMutation, GlobalStateProvider } from './global-state-service';\nimport { useOfflineInterface } from './offline-interface'; // Functions in here use the global state service to manage cacheable section\n// state in a performant way\n\n/**\n * Helper that transforms an array of cached section objects from the IndexedDB\n * into an object of values keyed by section ID\n *\n * @param {Array} list - An array of section objects\n * @returns {Object} An object of sections, keyed by ID\n */\n\nfunction getSectionsById(sectionsArray) {\n  return sectionsArray.reduce((result, _ref) => {\n    let {\n      sectionId,\n      lastUpdated\n    } = _ref;\n    return { ...result,\n      [sectionId]: {\n        lastUpdated\n      }\n    };\n  }, {});\n}\n/**\n * Create a store for Cacheable Section state.\n * Expected to be used in app adapter\n */\n\n\nexport function createCacheableSectionStore() {\n  const initialState = {\n    recordingStates: {},\n    cachedSections: {}\n  };\n  return createStore(initialState);\n}\n/**\n * Helper hook that returns a value that will persist between renders but makes\n * sure to only set its initial state once.\n * See https://gist.github.com/amcgee/42bb2fa6d5f79e607f00e6dccc733482\n */\n\nfunction useConst(factory) {\n  const ref = React.useRef(null);\n\n  if (ref.current === null) {\n    ref.current = factory();\n  }\n\n  return ref.current;\n}\n/**\n * Provides context for a global state context which will track cached\n * sections' status and cacheable sections' recording states, which will\n * determine how that component will render. The provider will be a part of\n * the OfflineProvider.\n */\n\n\nexport function CacheableSectionProvider(_ref2) {\n  let {\n    children\n  } = _ref2;\n  const offlineInterface = useOfflineInterface();\n  const store = useConst(createCacheableSectionStore); // On load, get sections and add to store\n\n  React.useEffect(() => {\n    if (offlineInterface) {\n      offlineInterface.getCachedSections().then(sections => {\n        store.mutate(state => ({ ...state,\n          cachedSections: getSectionsById(sections)\n        }));\n      });\n    }\n  }, [store, offlineInterface]);\n  return /*#__PURE__*/React.createElement(GlobalStateProvider, {\n    store: store\n  }, children);\n}\nCacheableSectionProvider.propTypes = {\n  children: PropTypes.node\n};\n/**\n * Uses an optimized global state to manage 'recording state' values without\n * unnecessarily rerendering all consuming components\n *\n * @param {String} id - ID of the cacheable section to track\n * @returns {Object} { recordingState: String, setRecordingState: Function, removeRecordingState: Function}\n */\n\nexport function useRecordingState(id) {\n  const [recordingState] = useGlobalState(state => state.recordingStates[id]);\n  const setRecordingState = useGlobalStateMutation(newState => state => ({ ...state,\n    recordingStates: { ...state.recordingStates,\n      [id]: newState\n    }\n  }));\n  const removeRecordingState = useGlobalStateMutation(() => state => {\n    const recordingStates = { ...state.recordingStates\n    };\n    delete recordingStates[id];\n    return { ...state,\n      recordingStates\n    };\n  });\n  return {\n    recordingState,\n    setRecordingState,\n    removeRecordingState\n  };\n}\n/**\n * Returns a function that syncs cached sections in the global state\n * with IndexedDB, so that IndexedDB is the single source of truth\n *\n * @returns {Function} syncCachedSections\n */\n\nfunction useSyncCachedSections() {\n  const offlineInterface = useOfflineInterface();\n  const setCachedSections = useGlobalStateMutation(cachedSections => state => ({ ...state,\n    cachedSections\n  }));\n  return async function syncCachedSections() {\n    const sections = await offlineInterface.getCachedSections();\n    setCachedSections(getSectionsById(sections));\n  };\n}\n/**\n * Uses global state to manage an object of cached sections' statuses\n *\n * @returns {Object} { cachedSections: Object, removeSection: Function }\n */\n\n\nexport function useCachedSections() {\n  const [cachedSections] = useGlobalState(state => state.cachedSections);\n  const syncCachedSections = useSyncCachedSections();\n  const offlineInterface = useOfflineInterface();\n  /**\n   * Uses offline interface to remove a section from IndexedDB and Cache\n   * Storage.\n   *\n   * Returns a promise that resolves to `true` if a section is found and\n   * deleted, or `false` if asection with the specified ID does not exist.\n   */\n\n  async function removeById(id) {\n    const success = await offlineInterface.removeSection(id);\n\n    if (success) {\n      await syncCachedSections();\n    }\n\n    return success;\n  }\n\n  return {\n    cachedSections,\n    removeById,\n    syncCachedSections\n  };\n}\n/**\n * Uses global state to manage the cached status of just one section, which\n * prevents unnecessary rerenders of consuming components\n *\n * @param {String} id\n * @returns {Object} { lastUpdated: Date, remove: Function }\n */\n\nexport function useCachedSection(id) {\n  const [status] = useGlobalState(state => state.cachedSections[id]);\n  const syncCachedSections = useSyncCachedSections();\n  const offlineInterface = useOfflineInterface();\n  const lastUpdated = status && status.lastUpdated;\n  /**\n   * Uses offline interface to remove a section from IndexedDB and Cache\n   * Storage.\n   *\n   * Returns `true` if a section is found and deleted, or `false` if a\n   * section with the specified ID does not exist.\n   */\n\n  async function remove() {\n    const success = await offlineInterface.removeSection(id);\n\n    if (success) {\n      await syncCachedSections();\n    }\n\n    return success;\n  }\n\n  return {\n    lastUpdated,\n    isCached: !!lastUpdated,\n    remove,\n    syncCachedSections\n  };\n}","map":{"version":3,"names":["PropTypes","React","createStore","useGlobalState","useGlobalStateMutation","GlobalStateProvider","useOfflineInterface","getSectionsById","sectionsArray","reduce","result","sectionId","lastUpdated","createCacheableSectionStore","initialState","recordingStates","cachedSections","useConst","factory","ref","useRef","current","CacheableSectionProvider","children","offlineInterface","store","useEffect","getCachedSections","then","sections","mutate","state","createElement","propTypes","node","useRecordingState","id","recordingState","setRecordingState","newState","removeRecordingState","useSyncCachedSections","setCachedSections","syncCachedSections","useCachedSections","removeById","success","removeSection","useCachedSection","status","remove","isCached"],"sources":["/home/jake/SRC/visualization-navigator-ts/node_modules/@dhis2/app-runtime/node_modules/@dhis2/app-service-offline/build/es/lib/cacheable-section-state.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport { createStore, useGlobalState, useGlobalStateMutation, GlobalStateProvider } from './global-state-service';\nimport { useOfflineInterface } from './offline-interface'; // Functions in here use the global state service to manage cacheable section\n// state in a performant way\n\n/**\n * Helper that transforms an array of cached section objects from the IndexedDB\n * into an object of values keyed by section ID\n *\n * @param {Array} list - An array of section objects\n * @returns {Object} An object of sections, keyed by ID\n */\nfunction getSectionsById(sectionsArray) {\n  return sectionsArray.reduce((result, {\n    sectionId,\n    lastUpdated\n  }) => ({ ...result,\n    [sectionId]: {\n      lastUpdated\n    }\n  }), {});\n}\n/**\n * Create a store for Cacheable Section state.\n * Expected to be used in app adapter\n */\n\n\nexport function createCacheableSectionStore() {\n  const initialState = {\n    recordingStates: {},\n    cachedSections: {}\n  };\n  return createStore(initialState);\n}\n/**\n * Helper hook that returns a value that will persist between renders but makes\n * sure to only set its initial state once.\n * See https://gist.github.com/amcgee/42bb2fa6d5f79e607f00e6dccc733482\n */\n\nfunction useConst(factory) {\n  const ref = React.useRef(null);\n\n  if (ref.current === null) {\n    ref.current = factory();\n  }\n\n  return ref.current;\n}\n/**\n * Provides context for a global state context which will track cached\n * sections' status and cacheable sections' recording states, which will\n * determine how that component will render. The provider will be a part of\n * the OfflineProvider.\n */\n\n\nexport function CacheableSectionProvider({\n  children\n}) {\n  const offlineInterface = useOfflineInterface();\n  const store = useConst(createCacheableSectionStore); // On load, get sections and add to store\n\n  React.useEffect(() => {\n    if (offlineInterface) {\n      offlineInterface.getCachedSections().then(sections => {\n        store.mutate(state => ({ ...state,\n          cachedSections: getSectionsById(sections)\n        }));\n      });\n    }\n  }, [store, offlineInterface]);\n  return /*#__PURE__*/React.createElement(GlobalStateProvider, {\n    store: store\n  }, children);\n}\nCacheableSectionProvider.propTypes = {\n  children: PropTypes.node\n};\n\n/**\n * Uses an optimized global state to manage 'recording state' values without\n * unnecessarily rerendering all consuming components\n *\n * @param {String} id - ID of the cacheable section to track\n * @returns {Object} { recordingState: String, setRecordingState: Function, removeRecordingState: Function}\n */\nexport function useRecordingState(id) {\n  const [recordingState] = useGlobalState(state => state.recordingStates[id]);\n  const setRecordingState = useGlobalStateMutation(newState => state => ({ ...state,\n    recordingStates: { ...state.recordingStates,\n      [id]: newState\n    }\n  }));\n  const removeRecordingState = useGlobalStateMutation(() => state => {\n    const recordingStates = { ...state.recordingStates\n    };\n    delete recordingStates[id];\n    return { ...state,\n      recordingStates\n    };\n  });\n  return {\n    recordingState,\n    setRecordingState,\n    removeRecordingState\n  };\n}\n/**\n * Returns a function that syncs cached sections in the global state\n * with IndexedDB, so that IndexedDB is the single source of truth\n *\n * @returns {Function} syncCachedSections\n */\n\nfunction useSyncCachedSections() {\n  const offlineInterface = useOfflineInterface();\n  const setCachedSections = useGlobalStateMutation(cachedSections => state => ({ ...state,\n    cachedSections\n  }));\n  return async function syncCachedSections() {\n    const sections = await offlineInterface.getCachedSections();\n    setCachedSections(getSectionsById(sections));\n  };\n}\n\n/**\n * Uses global state to manage an object of cached sections' statuses\n *\n * @returns {Object} { cachedSections: Object, removeSection: Function }\n */\nexport function useCachedSections() {\n  const [cachedSections] = useGlobalState(state => state.cachedSections);\n  const syncCachedSections = useSyncCachedSections();\n  const offlineInterface = useOfflineInterface();\n  /**\n   * Uses offline interface to remove a section from IndexedDB and Cache\n   * Storage.\n   *\n   * Returns a promise that resolves to `true` if a section is found and\n   * deleted, or `false` if asection with the specified ID does not exist.\n   */\n\n  async function removeById(id) {\n    const success = await offlineInterface.removeSection(id);\n\n    if (success) {\n      await syncCachedSections();\n    }\n\n    return success;\n  }\n\n  return {\n    cachedSections,\n    removeById,\n    syncCachedSections\n  };\n}\n\n/**\n * Uses global state to manage the cached status of just one section, which\n * prevents unnecessary rerenders of consuming components\n *\n * @param {String} id\n * @returns {Object} { lastUpdated: Date, remove: Function }\n */\nexport function useCachedSection(id) {\n  const [status] = useGlobalState(state => state.cachedSections[id]);\n  const syncCachedSections = useSyncCachedSections();\n  const offlineInterface = useOfflineInterface();\n  const lastUpdated = status && status.lastUpdated;\n  /**\n   * Uses offline interface to remove a section from IndexedDB and Cache\n   * Storage.\n   *\n   * Returns `true` if a section is found and deleted, or `false` if a\n   * section with the specified ID does not exist.\n   */\n\n  async function remove() {\n    const success = await offlineInterface.removeSection(id);\n\n    if (success) {\n      await syncCachedSections();\n    }\n\n    return success;\n  }\n\n  return {\n    lastUpdated,\n    isCached: !!lastUpdated,\n    remove,\n    syncCachedSections\n  };\n}"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,YAAtB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,SAASC,WAAT,EAAsBC,cAAtB,EAAsCC,sBAAtC,EAA8DC,mBAA9D,QAAyF,wBAAzF;AACA,SAASC,mBAAT,QAAoC,qBAApC,C,CAA2D;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,eAAT,CAAyBC,aAAzB,EAAwC;EACtC,OAAOA,aAAa,CAACC,MAAd,CAAqB,CAACC,MAAD;IAAA,IAAS;MACnCC,SADmC;MAEnCC;IAFmC,CAAT;IAAA,OAGrB,EAAE,GAAGF,MAAL;MACL,CAACC,SAAD,GAAa;QACXC;MADW;IADR,CAHqB;EAAA,CAArB,EAOH,EAPG,CAAP;AAQD;AACD;AACA;AACA;AACA;;;AAGA,OAAO,SAASC,2BAAT,GAAuC;EAC5C,MAAMC,YAAY,GAAG;IACnBC,eAAe,EAAE,EADE;IAEnBC,cAAc,EAAE;EAFG,CAArB;EAIA,OAAOd,WAAW,CAACY,YAAD,CAAlB;AACD;AACD;AACA;AACA;AACA;AACA;;AAEA,SAASG,QAAT,CAAkBC,OAAlB,EAA2B;EACzB,MAAMC,GAAG,GAAGlB,KAAK,CAACmB,MAAN,CAAa,IAAb,CAAZ;;EAEA,IAAID,GAAG,CAACE,OAAJ,KAAgB,IAApB,EAA0B;IACxBF,GAAG,CAACE,OAAJ,GAAcH,OAAO,EAArB;EACD;;EAED,OAAOC,GAAG,CAACE,OAAX;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,SAASC,wBAAT,QAEJ;EAAA,IAFsC;IACvCC;EADuC,CAEtC;EACD,MAAMC,gBAAgB,GAAGlB,mBAAmB,EAA5C;EACA,MAAMmB,KAAK,GAAGR,QAAQ,CAACJ,2BAAD,CAAtB,CAFC,CAEoD;;EAErDZ,KAAK,CAACyB,SAAN,CAAgB,MAAM;IACpB,IAAIF,gBAAJ,EAAsB;MACpBA,gBAAgB,CAACG,iBAAjB,GAAqCC,IAArC,CAA0CC,QAAQ,IAAI;QACpDJ,KAAK,CAACK,MAAN,CAAaC,KAAK,KAAK,EAAE,GAAGA,KAAL;UACrBf,cAAc,EAAET,eAAe,CAACsB,QAAD;QADV,CAAL,CAAlB;MAGD,CAJD;IAKD;EACF,CARD,EAQG,CAACJ,KAAD,EAAQD,gBAAR,CARH;EASA,OAAO,aAAavB,KAAK,CAAC+B,aAAN,CAAoB3B,mBAApB,EAAyC;IAC3DoB,KAAK,EAAEA;EADoD,CAAzC,EAEjBF,QAFiB,CAApB;AAGD;AACDD,wBAAwB,CAACW,SAAzB,GAAqC;EACnCV,QAAQ,EAAEvB,SAAS,CAACkC;AADe,CAArC;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,iBAAT,CAA2BC,EAA3B,EAA+B;EACpC,MAAM,CAACC,cAAD,IAAmBlC,cAAc,CAAC4B,KAAK,IAAIA,KAAK,CAAChB,eAAN,CAAsBqB,EAAtB,CAAV,CAAvC;EACA,MAAME,iBAAiB,GAAGlC,sBAAsB,CAACmC,QAAQ,IAAIR,KAAK,KAAK,EAAE,GAAGA,KAAL;IACrEhB,eAAe,EAAE,EAAE,GAAGgB,KAAK,CAAChB,eAAX;MACf,CAACqB,EAAD,GAAMG;IADS;EADoD,CAAL,CAAlB,CAAhD;EAKA,MAAMC,oBAAoB,GAAGpC,sBAAsB,CAAC,MAAM2B,KAAK,IAAI;IACjE,MAAMhB,eAAe,GAAG,EAAE,GAAGgB,KAAK,CAAChB;IAAX,CAAxB;IAEA,OAAOA,eAAe,CAACqB,EAAD,CAAtB;IACA,OAAO,EAAE,GAAGL,KAAL;MACLhB;IADK,CAAP;EAGD,CAPkD,CAAnD;EAQA,OAAO;IACLsB,cADK;IAELC,iBAFK;IAGLE;EAHK,CAAP;AAKD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,qBAAT,GAAiC;EAC/B,MAAMjB,gBAAgB,GAAGlB,mBAAmB,EAA5C;EACA,MAAMoC,iBAAiB,GAAGtC,sBAAsB,CAACY,cAAc,IAAIe,KAAK,KAAK,EAAE,GAAGA,KAAL;IAC3Ef;EAD2E,CAAL,CAAxB,CAAhD;EAGA,OAAO,eAAe2B,kBAAf,GAAoC;IACzC,MAAMd,QAAQ,GAAG,MAAML,gBAAgB,CAACG,iBAAjB,EAAvB;IACAe,iBAAiB,CAACnC,eAAe,CAACsB,QAAD,CAAhB,CAAjB;EACD,CAHD;AAID;AAED;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASe,iBAAT,GAA6B;EAClC,MAAM,CAAC5B,cAAD,IAAmBb,cAAc,CAAC4B,KAAK,IAAIA,KAAK,CAACf,cAAhB,CAAvC;EACA,MAAM2B,kBAAkB,GAAGF,qBAAqB,EAAhD;EACA,MAAMjB,gBAAgB,GAAGlB,mBAAmB,EAA5C;EACA;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE,eAAeuC,UAAf,CAA0BT,EAA1B,EAA8B;IAC5B,MAAMU,OAAO,GAAG,MAAMtB,gBAAgB,CAACuB,aAAjB,CAA+BX,EAA/B,CAAtB;;IAEA,IAAIU,OAAJ,EAAa;MACX,MAAMH,kBAAkB,EAAxB;IACD;;IAED,OAAOG,OAAP;EACD;;EAED,OAAO;IACL9B,cADK;IAEL6B,UAFK;IAGLF;EAHK,CAAP;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,gBAAT,CAA0BZ,EAA1B,EAA8B;EACnC,MAAM,CAACa,MAAD,IAAW9C,cAAc,CAAC4B,KAAK,IAAIA,KAAK,CAACf,cAAN,CAAqBoB,EAArB,CAAV,CAA/B;EACA,MAAMO,kBAAkB,GAAGF,qBAAqB,EAAhD;EACA,MAAMjB,gBAAgB,GAAGlB,mBAAmB,EAA5C;EACA,MAAMM,WAAW,GAAGqC,MAAM,IAAIA,MAAM,CAACrC,WAArC;EACA;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE,eAAesC,MAAf,GAAwB;IACtB,MAAMJ,OAAO,GAAG,MAAMtB,gBAAgB,CAACuB,aAAjB,CAA+BX,EAA/B,CAAtB;;IAEA,IAAIU,OAAJ,EAAa;MACX,MAAMH,kBAAkB,EAAxB;IACD;;IAED,OAAOG,OAAP;EACD;;EAED,OAAO;IACLlC,WADK;IAELuC,QAAQ,EAAE,CAAC,CAACvC,WAFP;IAGLsC,MAHK;IAILP;EAJK,CAAP;AAMD"},"metadata":{},"sourceType":"module"}