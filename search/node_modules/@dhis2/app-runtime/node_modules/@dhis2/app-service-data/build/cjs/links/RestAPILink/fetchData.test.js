"use strict";

var _engine = require("../../engine");

var _fetchData = require("./fetchData");

describe('networkFetch', () => {
  describe('parseContentType', () => {
    it('should pass through simple content-types', () => {
      expect((0, _fetchData.parseContentType)('text/html')).toBe('text/html');
      expect((0, _fetchData.parseContentType)('text/plain')).toBe('text/plain');
      expect((0, _fetchData.parseContentType)('application/vnd.api+json')).toBe('application/vnd.api+json');
    });
    it('should strip parameters', () => {
      expect((0, _fetchData.parseContentType)('text/svg+xml;charset=utf-8')).toBe('text/svg+xml');
      expect((0, _fetchData.parseContentType)('text/html;testing123')).toBe('text/html');
    });
    it('should trim type', () => {
      expect((0, _fetchData.parseContentType)('   text/xml ')).toBe('text/xml');
      expect((0, _fetchData.parseContentType)(' application/json ; charset = utf-8')).toBe('application/json');
    });
    it('should convert to lower-case', () => {
      expect((0, _fetchData.parseContentType)('  Text/XML ')).toBe('text/xml');
      expect((0, _fetchData.parseContentType)('application/JSON ; charset = UTF-8')).toBe('application/json');
    });
    it('should correctly parse application/json with charset param', () => {
      expect((0, _fetchData.parseContentType)('application/json;charset=UTF-8')).toBe('application/json');
    });
  });
  describe('parseStatus', () => {
    it('should pass through the response for a success status code', async () => {
      const response = {
        status: 200
      };
      await expect((0, _fetchData.parseStatus)(response)).resolves.toBe(response);
    });
    it('should throw an access error for 401, 403 and 409 errors', async () => {
      const response401 = {
        status: 401,
        json: async () => {
          throw new Error();
        }
      };
      const response403 = {
        status: 403,
        json: async () => {
          throw new Error();
        }
      };
      const response409 = {
        status: 409,
        json: async () => ({
          message: 'An error occurred'
        })
      };
      expect((0, _fetchData.parseStatus)(response401)).rejects.toMatchObject({
        type: 'access',
        message: 'Unauthorized',
        details: {}
      });
      expect((0, _fetchData.parseStatus)(response403)).rejects.toMatchObject({
        type: 'access',
        message: 'Forbidden',
        details: {}
      });
      expect((0, _fetchData.parseStatus)(response409)).rejects.toMatchObject({
        type: 'access',
        message: 'An error occurred',
        details: {
          message: 'An error occurred'
        }
      });
    });
    it('should throw if an unknown error occurs', () => {
      const response = {
        status: 500,
        statusText: 'Failed',
        json: async () => ({
          message: 'An error occurred'
        })
      };
      expect((0, _fetchData.parseStatus)(response)).rejects.toMatchObject({
        type: 'unknown',
        message: "An unknown error occurred - Failed (500)",
        details: {
          message: 'An error occurred'
        }
      });
    });
  });
  describe('fetchData', () => {
    const headers = {
      'Content-Type': type => type === 'json' ? 'application/json' : type === 'text' ? 'text/plain' : 'some/other-content-type'
    };
    const mockFetch = jest.fn(async url => ({
      status: 200,
      headers: {
        get: name => headers[name] && headers[name](url)
      },
      json: async () => ({
        foo: 'bar'
      }),
      text: async () => 'foobar',
      blob: async () => 'blob of foobar'
    }));
    beforeEach(() => {
      jest.clearAllMocks();
    });
    it('Should correctly parse a successful JSON response', () => {
      ;
      global.fetch = mockFetch;
      expect((0, _fetchData.fetchData)('json', {})).resolves.toMatchObject({
        foo: 'bar'
      });
    });
    it('Should correctly parse a successful TEXT response', () => {
      ;
      global.fetch = mockFetch;
      expect((0, _fetchData.fetchData)('text')).resolves.toBe('foobar');
    });
    it('Should correctly parse a successful BLOB response', () => {
      ;
      global.fetch = mockFetch;
      expect((0, _fetchData.fetchData)('something else')).resolves.toBe('blob of foobar');
    });
    it('Should throw a FetchError if fetch fails', () => {
      ;
      global.fetch = jest.fn(async () => {
        throw new Error();
      });
      expect((0, _fetchData.fetchData)('failure', {})).rejects.toBeInstanceOf(_engine.FetchError);
    });
  });
});