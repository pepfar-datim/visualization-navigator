"use strict";

var _steps = require("cypress-cucumber-preprocessor/steps");

Cypress.on('uncaught:exception', err => {
  // This prevents a benign error:
  //   This error means that ResizeObserver was not able to deliver all
  //   observations within a single animation frame. It is benign (your site
  //   will not break).
  //
  // Source: https://stackoverflow.com/a/50387233/1319140
  if (err.match(/ResizeObserver loop limit exceeded/)) {
    return false;
  }
});
(0, _steps.Given)('the Transfer has enough items to fill the source list completely', () => {
  cy.visitStory('Transfer End Of List', 'Full Source List');
  cy.wrap('source').as('listType');
});
(0, _steps.Given)('the Transfer has enough items to fill the picked list completely', () => {
  cy.visitStory('Transfer End Of List', 'Full Picked List');
  cy.wrap('picked').as('listType');
});
(0, _steps.Given)('the Transfer does not have enough items to fill the source list completely', () => {
  cy.visitStory('Transfer End Of List', 'Partial Source List');
  cy.wrap('source').as('listType');
});
(0, _steps.Given)('the Transfer does not have enough items to fill the picked list completely', () => {
  cy.visitStory('Transfer End Of List', 'Partial Picked List');
  cy.wrap('picked').as('listType');
});
(0, _steps.When)('the user scroll to the end of the list', () => {
  cy.get('@listType').then(listType => {
    const listSelector = listType === 'source' ? 'transfer-sourceoptions' : 'transfer-pickedoptions';
    cy.get("{".concat(listSelector, "-endintersectiondetector}")).scrollIntoView();
  });
});
(0, _steps.Then)('the callback for reaching the end should not be called', () => {
  cy.all(() => cy.window(), () => cy.get('@listType')).should(_ref => {
    let [win, listType] = _ref;
    const callback = listType === 'source' ? win.onEndReached : win.onEndReachedPicked;
    expect(callback).to.not.be.called;
  });
});
(0, _steps.Then)('the callback for reaching the end should be called', () => {
  cy.all(() => cy.window(), () => cy.get('@listType')).should(_ref2 => {
    let [win, listType] = _ref2;
    const callback = listType === 'source' ? win.onEndReached : win.onEndReachedPicked;
    expect(callback).to.be.calledOnce;
  });
});