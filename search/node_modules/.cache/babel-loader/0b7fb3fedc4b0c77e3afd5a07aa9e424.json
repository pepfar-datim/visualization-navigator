{"ast":null,"code":"import _asyncToGenerator from \"/home/jake/SRC/visualization-navigator-ts/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/home/jake/SRC/visualization-navigator-ts/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/home/jake/SRC/visualization-navigator-ts/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/home/jake/SRC/visualization-navigator-ts/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/home/jake/SRC/visualization-navigator-ts/node_modules/@babel/runtime/regenerator/index.js\";\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { createStore, useGlobalState, useGlobalStateMutation, GlobalStateProvider } from './global-state-service';\nimport { useOfflineInterface } from './offline-interface'; // Functions in here use the global state service to manage cacheable section\n// state in a performant way\n\n/**\n * Helper that transforms an array of cached section objects from the IndexedDB\n * into an object of values keyed by section ID\n *\n * @param {Array} list - An array of section objects\n * @returns {Object} An object of sections, keyed by ID\n */\n\nfunction getSectionsById(sectionsArray) {\n  return sectionsArray.reduce(function (result, _ref) {\n    var sectionId = _ref.sectionId,\n        lastUpdated = _ref.lastUpdated;\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, sectionId, {\n      lastUpdated: lastUpdated\n    }));\n  }, {});\n}\n/**\n * Create a store for Cacheable Section state.\n * Expected to be used in app adapter\n */\n\n\nexport function createCacheableSectionStore() {\n  var initialState = {\n    recordingStates: {},\n    cachedSections: {}\n  };\n  return createStore(initialState);\n}\n/**\n * Helper hook that returns a value that will persist between renders but makes\n * sure to only set its initial state once.\n * See https://gist.github.com/amcgee/42bb2fa6d5f79e607f00e6dccc733482\n */\n\nfunction useConst(factory) {\n  var ref = React.useRef(null);\n\n  if (ref.current === null) {\n    ref.current = factory();\n  }\n\n  return ref.current;\n}\n/**\n * Provides context for a global state context which will track cached\n * sections' status and cacheable sections' recording states, which will\n * determine how that component will render. The provider will be a part of\n * the OfflineProvider.\n */\n\n\nexport function CacheableSectionProvider(_ref2) {\n  var children = _ref2.children;\n  var offlineInterface = useOfflineInterface();\n  var store = useConst(createCacheableSectionStore); // On load, get sections and add to store\n\n  React.useEffect(function () {\n    if (offlineInterface) {\n      offlineInterface.getCachedSections().then(function (sections) {\n        store.mutate(function (state) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            cachedSections: getSectionsById(sections)\n          });\n        });\n      });\n    }\n  }, [store, offlineInterface]);\n  return /*#__PURE__*/React.createElement(GlobalStateProvider, {\n    store: store\n  }, children);\n}\nCacheableSectionProvider.propTypes = {\n  children: PropTypes.node\n};\n/**\n * Uses an optimized global state to manage 'recording state' values without\n * unnecessarily rerendering all consuming components\n *\n * @param {String} id - ID of the cacheable section to track\n * @returns {Object} { recordingState: String, setRecordingState: Function, removeRecordingState: Function}\n */\n\nexport function useRecordingState(id) {\n  var _useGlobalState = useGlobalState(function (state) {\n    return state.recordingStates[id];\n  }),\n      _useGlobalState2 = _slicedToArray(_useGlobalState, 1),\n      recordingState = _useGlobalState2[0];\n\n  var setRecordingState = useGlobalStateMutation(function (newState) {\n    return function (state) {\n      return _objectSpread(_objectSpread({}, state), {}, {\n        recordingStates: _objectSpread(_objectSpread({}, state.recordingStates), {}, _defineProperty({}, id, newState))\n      });\n    };\n  });\n  var removeRecordingState = useGlobalStateMutation(function () {\n    return function (state) {\n      var recordingStates = _objectSpread({}, state.recordingStates);\n\n      delete recordingStates[id];\n      return _objectSpread(_objectSpread({}, state), {}, {\n        recordingStates: recordingStates\n      });\n    };\n  });\n  return {\n    recordingState: recordingState,\n    setRecordingState: setRecordingState,\n    removeRecordingState: removeRecordingState\n  };\n}\n/**\n * Returns a function that syncs cached sections in the global state\n * with IndexedDB, so that IndexedDB is the single source of truth\n *\n * @returns {Function} syncCachedSections\n */\n\nfunction useSyncCachedSections() {\n  var offlineInterface = useOfflineInterface();\n  var setCachedSections = useGlobalStateMutation(function (cachedSections) {\n    return function (state) {\n      return _objectSpread(_objectSpread({}, state), {}, {\n        cachedSections: cachedSections\n      });\n    };\n  });\n  return /*#__PURE__*/function () {\n    var _syncCachedSections = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var sections;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return offlineInterface.getCachedSections();\n\n            case 2:\n              sections = _context.sent;\n              setCachedSections(getSectionsById(sections));\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function syncCachedSections() {\n      return _syncCachedSections.apply(this, arguments);\n    }\n\n    return syncCachedSections;\n  }();\n}\n/**\n * Uses global state to manage an object of cached sections' statuses\n *\n * @returns {Object} { cachedSections: Object, removeSection: Function }\n */\n\n\nexport function useCachedSections() {\n  var _useGlobalState3 = useGlobalState(function (state) {\n    return state.cachedSections;\n  }),\n      _useGlobalState4 = _slicedToArray(_useGlobalState3, 1),\n      cachedSections = _useGlobalState4[0];\n\n  var syncCachedSections = useSyncCachedSections();\n  var offlineInterface = useOfflineInterface();\n  /**\n   * Uses offline interface to remove a section from IndexedDB and Cache\n   * Storage.\n   *\n   * Returns a promise that resolves to `true` if a section is found and\n   * deleted, or `false` if asection with the specified ID does not exist.\n   */\n\n  function removeById(_x) {\n    return _removeById.apply(this, arguments);\n  }\n\n  function _removeById() {\n    _removeById = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(id) {\n      var success;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return offlineInterface.removeSection(id);\n\n            case 2:\n              success = _context2.sent;\n\n              if (!success) {\n                _context2.next = 6;\n                break;\n              }\n\n              _context2.next = 6;\n              return syncCachedSections();\n\n            case 6:\n              return _context2.abrupt(\"return\", success);\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _removeById.apply(this, arguments);\n  }\n\n  return {\n    cachedSections: cachedSections,\n    removeById: removeById,\n    syncCachedSections: syncCachedSections\n  };\n}\n/**\n * Uses global state to manage the cached status of just one section, which\n * prevents unnecessary rerenders of consuming components\n *\n * @param {String} id\n * @returns {Object} { lastUpdated: Date, remove: Function }\n */\n\nexport function useCachedSection(id) {\n  var _useGlobalState5 = useGlobalState(function (state) {\n    return state.cachedSections[id];\n  }),\n      _useGlobalState6 = _slicedToArray(_useGlobalState5, 1),\n      status = _useGlobalState6[0];\n\n  var syncCachedSections = useSyncCachedSections();\n  var offlineInterface = useOfflineInterface();\n  var lastUpdated = status && status.lastUpdated;\n  /**\n   * Uses offline interface to remove a section from IndexedDB and Cache\n   * Storage.\n   *\n   * Returns `true` if a section is found and deleted, or `false` if a\n   * section with the specified ID does not exist.\n   */\n\n  function remove() {\n    return _remove.apply(this, arguments);\n  }\n\n  function _remove() {\n    _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var success;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return offlineInterface.removeSection(id);\n\n            case 2:\n              success = _context3.sent;\n\n              if (!success) {\n                _context3.next = 6;\n                break;\n              }\n\n              _context3.next = 6;\n              return syncCachedSections();\n\n            case 6:\n              return _context3.abrupt(\"return\", success);\n\n            case 7:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return _remove.apply(this, arguments);\n  }\n\n  return {\n    lastUpdated: lastUpdated,\n    isCached: !!lastUpdated,\n    remove: remove,\n    syncCachedSections: syncCachedSections\n  };\n}","map":{"version":3,"names":["PropTypes","React","createStore","useGlobalState","useGlobalStateMutation","GlobalStateProvider","useOfflineInterface","getSectionsById","sectionsArray","reduce","result","sectionId","lastUpdated","createCacheableSectionStore","initialState","recordingStates","cachedSections","useConst","factory","ref","useRef","current","CacheableSectionProvider","children","offlineInterface","store","useEffect","getCachedSections","then","sections","mutate","state","createElement","propTypes","node","useRecordingState","id","recordingState","setRecordingState","newState","removeRecordingState","useSyncCachedSections","setCachedSections","syncCachedSections","useCachedSections","removeById","removeSection","success","useCachedSection","status","remove","isCached"],"sources":["/home/jake/SRC/visualization-navigator-ts/node_modules/@dhis2/app-runtime/node_modules/@dhis2/app-service-offline/build/es/lib/cacheable-section-state.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport { createStore, useGlobalState, useGlobalStateMutation, GlobalStateProvider } from './global-state-service';\nimport { useOfflineInterface } from './offline-interface'; // Functions in here use the global state service to manage cacheable section\n// state in a performant way\n\n/**\n * Helper that transforms an array of cached section objects from the IndexedDB\n * into an object of values keyed by section ID\n *\n * @param {Array} list - An array of section objects\n * @returns {Object} An object of sections, keyed by ID\n */\nfunction getSectionsById(sectionsArray) {\n  return sectionsArray.reduce((result, {\n    sectionId,\n    lastUpdated\n  }) => ({ ...result,\n    [sectionId]: {\n      lastUpdated\n    }\n  }), {});\n}\n/**\n * Create a store for Cacheable Section state.\n * Expected to be used in app adapter\n */\n\n\nexport function createCacheableSectionStore() {\n  const initialState = {\n    recordingStates: {},\n    cachedSections: {}\n  };\n  return createStore(initialState);\n}\n/**\n * Helper hook that returns a value that will persist between renders but makes\n * sure to only set its initial state once.\n * See https://gist.github.com/amcgee/42bb2fa6d5f79e607f00e6dccc733482\n */\n\nfunction useConst(factory) {\n  const ref = React.useRef(null);\n\n  if (ref.current === null) {\n    ref.current = factory();\n  }\n\n  return ref.current;\n}\n/**\n * Provides context for a global state context which will track cached\n * sections' status and cacheable sections' recording states, which will\n * determine how that component will render. The provider will be a part of\n * the OfflineProvider.\n */\n\n\nexport function CacheableSectionProvider({\n  children\n}) {\n  const offlineInterface = useOfflineInterface();\n  const store = useConst(createCacheableSectionStore); // On load, get sections and add to store\n\n  React.useEffect(() => {\n    if (offlineInterface) {\n      offlineInterface.getCachedSections().then(sections => {\n        store.mutate(state => ({ ...state,\n          cachedSections: getSectionsById(sections)\n        }));\n      });\n    }\n  }, [store, offlineInterface]);\n  return /*#__PURE__*/React.createElement(GlobalStateProvider, {\n    store: store\n  }, children);\n}\nCacheableSectionProvider.propTypes = {\n  children: PropTypes.node\n};\n\n/**\n * Uses an optimized global state to manage 'recording state' values without\n * unnecessarily rerendering all consuming components\n *\n * @param {String} id - ID of the cacheable section to track\n * @returns {Object} { recordingState: String, setRecordingState: Function, removeRecordingState: Function}\n */\nexport function useRecordingState(id) {\n  const [recordingState] = useGlobalState(state => state.recordingStates[id]);\n  const setRecordingState = useGlobalStateMutation(newState => state => ({ ...state,\n    recordingStates: { ...state.recordingStates,\n      [id]: newState\n    }\n  }));\n  const removeRecordingState = useGlobalStateMutation(() => state => {\n    const recordingStates = { ...state.recordingStates\n    };\n    delete recordingStates[id];\n    return { ...state,\n      recordingStates\n    };\n  });\n  return {\n    recordingState,\n    setRecordingState,\n    removeRecordingState\n  };\n}\n/**\n * Returns a function that syncs cached sections in the global state\n * with IndexedDB, so that IndexedDB is the single source of truth\n *\n * @returns {Function} syncCachedSections\n */\n\nfunction useSyncCachedSections() {\n  const offlineInterface = useOfflineInterface();\n  const setCachedSections = useGlobalStateMutation(cachedSections => state => ({ ...state,\n    cachedSections\n  }));\n  return async function syncCachedSections() {\n    const sections = await offlineInterface.getCachedSections();\n    setCachedSections(getSectionsById(sections));\n  };\n}\n\n/**\n * Uses global state to manage an object of cached sections' statuses\n *\n * @returns {Object} { cachedSections: Object, removeSection: Function }\n */\nexport function useCachedSections() {\n  const [cachedSections] = useGlobalState(state => state.cachedSections);\n  const syncCachedSections = useSyncCachedSections();\n  const offlineInterface = useOfflineInterface();\n  /**\n   * Uses offline interface to remove a section from IndexedDB and Cache\n   * Storage.\n   *\n   * Returns a promise that resolves to `true` if a section is found and\n   * deleted, or `false` if asection with the specified ID does not exist.\n   */\n\n  async function removeById(id) {\n    const success = await offlineInterface.removeSection(id);\n\n    if (success) {\n      await syncCachedSections();\n    }\n\n    return success;\n  }\n\n  return {\n    cachedSections,\n    removeById,\n    syncCachedSections\n  };\n}\n\n/**\n * Uses global state to manage the cached status of just one section, which\n * prevents unnecessary rerenders of consuming components\n *\n * @param {String} id\n * @returns {Object} { lastUpdated: Date, remove: Function }\n */\nexport function useCachedSection(id) {\n  const [status] = useGlobalState(state => state.cachedSections[id]);\n  const syncCachedSections = useSyncCachedSections();\n  const offlineInterface = useOfflineInterface();\n  const lastUpdated = status && status.lastUpdated;\n  /**\n   * Uses offline interface to remove a section from IndexedDB and Cache\n   * Storage.\n   *\n   * Returns `true` if a section is found and deleted, or `false` if a\n   * section with the specified ID does not exist.\n   */\n\n  async function remove() {\n    const success = await offlineInterface.removeSection(id);\n\n    if (success) {\n      await syncCachedSections();\n    }\n\n    return success;\n  }\n\n  return {\n    lastUpdated,\n    isCached: !!lastUpdated,\n    remove,\n    syncCachedSections\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}