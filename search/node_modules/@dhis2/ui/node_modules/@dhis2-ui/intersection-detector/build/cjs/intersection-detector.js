"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IntersectionDetector = void 0;

var _style = _interopRequireDefault(require("styled-jsx/style"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const IntersectionDetector = _ref => {
  let {
    threshold,
    onChange,
    children,
    className,
    dataTest,
    rootRef
  } = _ref;
  // Use useRef instead of useState to prevent unnecessary re-render:
  //   The state changes won't be reflected in what this component renders,
  //   so there's no need for re-rendering the (potentially computational
  //   heavy) children.  Also: If the parent re-renders (e. g. due to a state
  //   change), then this component will re-render as well.
  // @var {Object}
  // @prop {bool} current
  const isIntersecting = (0, _react.useRef)(); // @var {Object}
  // @prop {HTMLElement} current

  const intersectionRef = (0, _react.useRef)();
  (0, _react.useEffect)(() => {
    const rootEl = rootRef.current;
    const intersectionEl = intersectionRef.current;

    if (rootEl && intersectionEl) {
      const onIntersection = entries => {
        // Currently there's no way to supply multiple thresholds,
        // so a single entry can be assumed safely
        const [entry] = entries; // Make sure the callback is not called multiple times
        // if there is no change

        const intersectionChange = entry.isIntersecting !== isIntersecting.current;

        if (intersectionChange) {
          isIntersecting.current = entry.isIntersecting;
          onChange({
            isIntersecting: entry.isIntersecting
          });
        }
      };

      const observerOptions = {
        root: rootEl,
        threshold
      };
      const intersectionObserver = new IntersectionObserver(onIntersection, observerOptions);
      intersectionObserver.observe(intersectionEl); // Make sure to clean up everything when un-mounting.
      // Using an arrow function instead of just returning
      // the disconnect function for better readability.

      return () => intersectionObserver.disconnect();
    }
  }, [rootRef.current, intersectionRef.current]);
  return /*#__PURE__*/_react.default.createElement("div", {
    ref: intersectionRef,
    "data-test": dataTest,
    className: "jsx-2829611397" + " " + (className || "")
  }, children, /*#__PURE__*/_react.default.createElement(_style.default, {
    id: "2829611397"
  }, ["div.jsx-2829611397{height:100%;}"]));
};

exports.IntersectionDetector = IntersectionDetector;
IntersectionDetector.defaultProps = {
  threshold: 0,
  dataTest: 'dhis2-uicore-intersectiondetector'
};
IntersectionDetector.propTypes = {
  /** React ref on other component to detect intersections with */
  rootRef: _propTypes.default.shape({
    // not required so `current` can be `null`
    current: _propTypes.default.instanceOf(HTMLElement)
  }).isRequired,

  /** Called with signature `({ isIntersecting: bool })` */
  onChange: _propTypes.default.func.isRequired,
  children: _propTypes.default.any,
  className: _propTypes.default.string,
  dataTest: _propTypes.default.string,

  /** The [threshold](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Intersection_observer_options) value: a value from 0.0 to 1.0 that controls the point at which an intersecting component is considered 'intersected' or 'visible' and the onChange callback triggers */
  threshold: _propTypes.default.number
};