import PropTypes from 'prop-types';
import React from 'react';
import { RecordingState } from '../types';
interface CacheableSectionStartRecordingOptions {
    recordingTimeoutDelay?: number;
    onStarted?: () => void;
    onCompleted?: () => void;
    onError?: (err: Error) => void;
}
export declare type CacheableSectionStartRecording = (options?: CacheableSectionStartRecordingOptions) => Promise<any>;
interface CacheableSectionControls {
    recordingState: RecordingState;
    startRecording: CacheableSectionStartRecording;
    lastUpdated: Date | undefined;
    isCached: boolean;
    remove: () => Promise<boolean>;
}
/**
 * Returns the main controls for a cacheable section and manages recording
 * state, which affects the render state of the CacheableSection component.
 * Also returns the cached status of the section, which come straight from
 * the `useCachedSection` hook.
 *
 * @param {String} id
 * @returns {Object}
 */
export declare function useCacheableSection(id: string): CacheableSectionControls;
interface CacheableSectionProps {
    id: string;
    loadingMask: JSX.Element;
    children: React.ReactNode;
}
/**
 * Used to wrap the relevant component to be recorded and saved offline.
 * Depending on the recording state of the section, this wrapper will
 * render its children, not render its children while recording is pending,
 * or RErerender the chilren to force data fetching to record by the service
 * worker.
 *
 * During recording, a loading mask provided by props is also rendered that is
 * intended to prevent other interaction with the app that might interfere
 * with the recording process.
 */
export declare function CacheableSection({ id, loadingMask, children, }: CacheableSectionProps): JSX.Element;
export declare namespace CacheableSection {
    var propTypes: {
        id: PropTypes.Validator<string>;
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        loadingMask: PropTypes.Requireable<PropTypes.ReactNodeLike>;
    };
}
export {};
