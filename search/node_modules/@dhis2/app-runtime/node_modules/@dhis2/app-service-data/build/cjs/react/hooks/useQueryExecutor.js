"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useQueryExecutor = void 0;

var _react = require("react");

var _engine = require("../../engine");

var _useStaticInput = require("./useStaticInput");

const useQueryExecutor = ({
  execute,
  variables: initialVariables,
  singular,
  immediate,
  onComplete,
  onError
}) => {
  const [theExecute] = (0, _useStaticInput.useStaticInput)(execute);
  const [state, setState] = (0, _react.useState)({
    called: !!immediate,
    loading: !!immediate
  });
  const variables = (0, _react.useRef)(initialVariables);
  const abortControllersRef = (0, _react.useRef)([]);
  const abort = (0, _react.useCallback)(() => {
    abortControllersRef.current.forEach(controller => controller.abort());
    abortControllersRef.current = [];
  }, []);
  const manualAbort = (0, _react.useCallback)(() => {
    abort();
    setState(state => ({
      called: state.called,
      loading: false,
      error: new _engine.FetchError({
        type: 'aborted',
        message: 'Aborted'
      })
    }));
  }, [abort]);
  const refetch = (0, _react.useCallback)((newVariables = {}) => {
    setState(state => !state.called || !state.loading ? {
      called: true,
      loading: true
    } : state);

    if (singular) {
      abort(); // Cleanup any in-progress fetches
    }

    const controller = new AbortController();
    abortControllersRef.current.push(controller);
    variables.current = { ...variables.current,
      ...newVariables
    };
    const options = {
      variables: variables.current,
      signal: controller.signal,
      onComplete,
      onError
    };
    return theExecute(options).then(data => {
      if (!controller.signal.aborted) {
        setState({
          called: true,
          loading: false,
          data
        });
        return data;
      }

      return new Promise(() => undefined); // Wait forever
    }).catch(error => {
      if (!controller.signal.aborted) {
        setState({
          called: true,
          loading: false,
          error
        });
      }

      return new Promise(() => undefined); // Don't throw errors in refetch promises, wait forever
    });
  }, [abort, onComplete, onError, singular, theExecute]); // Don't include immediate or refetch as deps, otherwise unintentional refetches
  // may be triggered by changes to input, i.e. recreating the onComplete callback

  (0, _react.useEffect)(() => {
    if (immediate) {
      refetch();
    }

    return abort;
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  return {
    refetch,
    abort: manualAbort,
    ...state
  };
};

exports.useQueryExecutor = useQueryExecutor;