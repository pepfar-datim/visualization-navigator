{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport * as utils from './utils.js';\nimport baseLogger from './logger.js';\n\nvar Interpolator = function () {\n  function Interpolator() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Interpolator);\n\n    this.logger = baseLogger.create('interpolator');\n    this.init(options, true);\n  }\n  /* eslint no-param-reassign: 0 */\n\n\n  Interpolator.prototype.init = function init() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var reset = arguments[1];\n\n    if (reset) {\n      this.options = options;\n\n      this.format = options.interpolation && options.interpolation.format || function (value) {\n        return value;\n      };\n\n      this.escape = options.interpolation && options.interpolation.escape || utils.escape;\n    }\n\n    if (!options.interpolation) options.interpolation = {\n      escapeValue: true\n    };\n    var iOpts = options.interpolation;\n    this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n    this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n    this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n    this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n    this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n    this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');\n    this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');\n    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000; // the regexp\n\n    this.resetRegExp();\n  };\n\n  Interpolator.prototype.reset = function reset() {\n    if (this.options) this.init(this.options);\n  };\n\n  Interpolator.prototype.resetRegExp = function resetRegExp() {\n    // the regexp\n    var regexpStr = this.prefix + '(.+?)' + this.suffix;\n    this.regexp = new RegExp(regexpStr, 'g');\n    var regexpUnescapeStr = '' + this.prefix + this.unescapePrefix + '(.+?)' + this.unescapeSuffix + this.suffix;\n    this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n    var nestingRegexpStr = this.nestingPrefix + '(.+?)' + this.nestingSuffix;\n    this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n  };\n\n  Interpolator.prototype.interpolate = function interpolate(str, data, lng) {\n    var _this = this;\n\n    var match = void 0;\n    var value = void 0;\n    var replaces = void 0;\n\n    function regexSafe(val) {\n      return val.replace(/\\$/g, '$$$$');\n    }\n\n    var handleFormat = function handleFormat(key) {\n      if (key.indexOf(_this.formatSeparator) < 0) return utils.getPath(data, key);\n      var p = key.split(_this.formatSeparator);\n      var k = p.shift().trim();\n      var f = p.join(_this.formatSeparator).trim();\n      return _this.format(utils.getPath(data, k), f, lng);\n    };\n\n    this.resetRegExp();\n    replaces = 0; // unescape if has unescapePrefix/Suffix\n\n    /* eslint no-cond-assign: 0 */\n\n    while (match = this.regexpUnescape.exec(str)) {\n      value = handleFormat(match[1].trim());\n      str = str.replace(match[0], value);\n      this.regexpUnescape.lastIndex = 0;\n      replaces++;\n\n      if (replaces >= this.maxReplaces) {\n        break;\n      }\n    }\n\n    replaces = 0; // regular escape on demand\n\n    while (match = this.regexp.exec(str)) {\n      value = handleFormat(match[1].trim());\n      if (typeof value !== 'string') value = utils.makeString(value);\n\n      if (!value) {\n        if (typeof this.options.missingInterpolationHandler === 'function') {\n          var temp = this.options.missingInterpolationHandler(str, match);\n          value = typeof temp === 'string' ? temp : '';\n        } else {\n          this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);\n          value = '';\n        }\n      }\n\n      value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n      replaces++;\n\n      if (replaces >= this.maxReplaces) {\n        break;\n      }\n    }\n\n    return str;\n  };\n\n  Interpolator.prototype.nest = function nest(str, fc) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var match = void 0;\n    var value = void 0;\n\n    var clonedOptions = _extends({}, options);\n\n    clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup\n    // if value is something like \"myKey\": \"lorem $(anotherKey, { \"count\": {{aValueInOptions}} })\"\n\n    function handleHasOptions(key, inheritedOptions) {\n      if (key.indexOf(',') < 0) return key;\n      var p = key.split(',');\n      key = p.shift();\n      var optionsString = p.join(',');\n      optionsString = this.interpolate(optionsString, clonedOptions);\n      optionsString = optionsString.replace(/'/g, '\"');\n\n      try {\n        clonedOptions = JSON.parse(optionsString);\n        if (inheritedOptions) clonedOptions = _extends({}, inheritedOptions, clonedOptions);\n      } catch (e) {\n        this.logger.error('failed parsing options string in nesting for key ' + key, e);\n      }\n\n      return key;\n    } // regular escape on demand\n\n\n    while (match = this.nestingRegexp.exec(str)) {\n      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions); // is only the nesting key (key1 = '$(key2)') return the value without stringify\n\n      if (value && match[0] === str && typeof value !== 'string') return value; // no string to include or empty\n\n      if (typeof value !== 'string') value = utils.makeString(value);\n\n      if (!value) {\n        this.logger.warn('missed to resolve ' + match[1] + ' for nesting ' + str);\n        value = '';\n      } // Nested keys should not be escaped by default #854\n      // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);\n\n\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n    }\n\n    return str;\n  };\n\n  return Interpolator;\n}();\n\nexport default Interpolator;","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_classCallCheck","instance","Constructor","TypeError","utils","baseLogger","Interpolator","options","undefined","logger","create","init","reset","format","interpolation","value","escape","escapeValue","iOpts","prefix","regexEscape","prefixEscaped","suffix","suffixEscaped","formatSeparator","unescapePrefix","unescapeSuffix","nestingPrefix","nestingPrefixEscaped","nestingSuffix","nestingSuffixEscaped","maxReplaces","resetRegExp","regexpStr","regexp","RegExp","regexpUnescapeStr","regexpUnescape","nestingRegexpStr","nestingRegexp","interpolate","str","data","lng","_this","match","replaces","regexSafe","val","replace","handleFormat","indexOf","getPath","p","split","k","shift","trim","f","join","exec","lastIndex","makeString","missingInterpolationHandler","temp","warn","nest","fc","clonedOptions","applyPostProcessor","handleHasOptions","inheritedOptions","optionsString","JSON","parse","e","error"],"sources":["/home/jake/SRC/landing-page/node_modules/i18next/dist/es/Interpolator.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport * as utils from './utils.js';\nimport baseLogger from './logger.js';\n\nvar Interpolator = function () {\n  function Interpolator() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Interpolator);\n\n    this.logger = baseLogger.create('interpolator');\n\n    this.init(options, true);\n  }\n\n  /* eslint no-param-reassign: 0 */\n\n\n  Interpolator.prototype.init = function init() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var reset = arguments[1];\n\n    if (reset) {\n      this.options = options;\n      this.format = options.interpolation && options.interpolation.format || function (value) {\n        return value;\n      };\n      this.escape = options.interpolation && options.interpolation.escape || utils.escape;\n    }\n    if (!options.interpolation) options.interpolation = { escapeValue: true };\n\n    var iOpts = options.interpolation;\n\n    this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n\n    this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n    this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n\n    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n\n    this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n    this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n\n    this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');\n    this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');\n\n    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n\n    // the regexp\n    this.resetRegExp();\n  };\n\n  Interpolator.prototype.reset = function reset() {\n    if (this.options) this.init(this.options);\n  };\n\n  Interpolator.prototype.resetRegExp = function resetRegExp() {\n    // the regexp\n    var regexpStr = this.prefix + '(.+?)' + this.suffix;\n    this.regexp = new RegExp(regexpStr, 'g');\n\n    var regexpUnescapeStr = '' + this.prefix + this.unescapePrefix + '(.+?)' + this.unescapeSuffix + this.suffix;\n    this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n\n    var nestingRegexpStr = this.nestingPrefix + '(.+?)' + this.nestingSuffix;\n    this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n  };\n\n  Interpolator.prototype.interpolate = function interpolate(str, data, lng) {\n    var _this = this;\n\n    var match = void 0;\n    var value = void 0;\n    var replaces = void 0;\n\n    function regexSafe(val) {\n      return val.replace(/\\$/g, '$$$$');\n    }\n\n    var handleFormat = function handleFormat(key) {\n      if (key.indexOf(_this.formatSeparator) < 0) return utils.getPath(data, key);\n\n      var p = key.split(_this.formatSeparator);\n      var k = p.shift().trim();\n      var f = p.join(_this.formatSeparator).trim();\n\n      return _this.format(utils.getPath(data, k), f, lng);\n    };\n\n    this.resetRegExp();\n\n    replaces = 0;\n    // unescape if has unescapePrefix/Suffix\n    /* eslint no-cond-assign: 0 */\n    while (match = this.regexpUnescape.exec(str)) {\n      value = handleFormat(match[1].trim());\n      str = str.replace(match[0], value);\n      this.regexpUnescape.lastIndex = 0;\n      replaces++;\n      if (replaces >= this.maxReplaces) {\n        break;\n      }\n    }\n\n    replaces = 0;\n    // regular escape on demand\n    while (match = this.regexp.exec(str)) {\n      value = handleFormat(match[1].trim());\n      if (typeof value !== 'string') value = utils.makeString(value);\n      if (!value) {\n        if (typeof this.options.missingInterpolationHandler === 'function') {\n          var temp = this.options.missingInterpolationHandler(str, match);\n          value = typeof temp === 'string' ? temp : '';\n        } else {\n          this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);\n          value = '';\n        }\n      }\n      value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n      replaces++;\n      if (replaces >= this.maxReplaces) {\n        break;\n      }\n    }\n    return str;\n  };\n\n  Interpolator.prototype.nest = function nest(str, fc) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var match = void 0;\n    var value = void 0;\n\n    var clonedOptions = _extends({}, options);\n    clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup\n\n    // if value is something like \"myKey\": \"lorem $(anotherKey, { \"count\": {{aValueInOptions}} })\"\n    function handleHasOptions(key, inheritedOptions) {\n      if (key.indexOf(',') < 0) return key;\n\n      var p = key.split(',');\n      key = p.shift();\n      var optionsString = p.join(',');\n      optionsString = this.interpolate(optionsString, clonedOptions);\n      optionsString = optionsString.replace(/'/g, '\"');\n\n      try {\n        clonedOptions = JSON.parse(optionsString);\n\n        if (inheritedOptions) clonedOptions = _extends({}, inheritedOptions, clonedOptions);\n      } catch (e) {\n        this.logger.error('failed parsing options string in nesting for key ' + key, e);\n      }\n\n      return key;\n    }\n\n    // regular escape on demand\n    while (match = this.nestingRegexp.exec(str)) {\n      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n\n      // is only the nesting key (key1 = '$(key2)') return the value without stringify\n      if (value && match[0] === str && typeof value !== 'string') return value;\n\n      // no string to include or empty\n      if (typeof value !== 'string') value = utils.makeString(value);\n      if (!value) {\n        this.logger.warn('missed to resolve ' + match[1] + ' for nesting ' + str);\n        value = '';\n      }\n      // Nested keys should not be escaped by default #854\n      // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n    }\n    return str;\n  };\n\n  return Interpolator;\n}();\n\nexport default Interpolator;"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,MAAP,IAAiB,UAAUC,MAAV,EAAkB;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;IAAE,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAtB;;IAA2B,KAAK,IAAII,GAAT,IAAgBD,MAAhB,EAAwB;MAAE,IAAIN,MAAM,CAACQ,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,MAArC,EAA6CC,GAA7C,CAAJ,EAAuD;QAAEL,MAAM,CAACK,GAAD,CAAN,GAAcD,MAAM,CAACC,GAAD,CAApB;MAA4B;IAAE;EAAE;;EAAC,OAAOL,MAAP;AAAgB,CAAhQ;;AAEA,SAASS,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;EAAE,IAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;IAAE,MAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;EAA2D;AAAE;;AAEzJ,OAAO,KAAKC,KAAZ,MAAuB,YAAvB;AACA,OAAOC,UAAP,MAAuB,aAAvB;;AAEA,IAAIC,YAAY,GAAG,YAAY;EAC7B,SAASA,YAAT,GAAwB;IACtB,IAAIC,OAAO,GAAGd,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBe,SAAzC,GAAqDf,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;;IAEAO,eAAe,CAAC,IAAD,EAAOM,YAAP,CAAf;;IAEA,KAAKG,MAAL,GAAcJ,UAAU,CAACK,MAAX,CAAkB,cAAlB,CAAd;IAEA,KAAKC,IAAL,CAAUJ,OAAV,EAAmB,IAAnB;EACD;EAED;;;EAGAD,YAAY,CAACT,SAAb,CAAuBc,IAAvB,GAA8B,SAASA,IAAT,GAAgB;IAC5C,IAAIJ,OAAO,GAAGd,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBe,SAAzC,GAAqDf,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;IACA,IAAImB,KAAK,GAAGnB,SAAS,CAAC,CAAD,CAArB;;IAEA,IAAImB,KAAJ,EAAW;MACT,KAAKL,OAAL,GAAeA,OAAf;;MACA,KAAKM,MAAL,GAAcN,OAAO,CAACO,aAAR,IAAyBP,OAAO,CAACO,aAAR,CAAsBD,MAA/C,IAAyD,UAAUE,KAAV,EAAiB;QACtF,OAAOA,KAAP;MACD,CAFD;;MAGA,KAAKC,MAAL,GAAcT,OAAO,CAACO,aAAR,IAAyBP,OAAO,CAACO,aAAR,CAAsBE,MAA/C,IAAyDZ,KAAK,CAACY,MAA7E;IACD;;IACD,IAAI,CAACT,OAAO,CAACO,aAAb,EAA4BP,OAAO,CAACO,aAAR,GAAwB;MAAEG,WAAW,EAAE;IAAf,CAAxB;IAE5B,IAAIC,KAAK,GAAGX,OAAO,CAACO,aAApB;IAEA,KAAKG,WAAL,GAAmBC,KAAK,CAACD,WAAN,KAAsBT,SAAtB,GAAkCU,KAAK,CAACD,WAAxC,GAAsD,IAAzE;IAEA,KAAKE,MAAL,GAAcD,KAAK,CAACC,MAAN,GAAef,KAAK,CAACgB,WAAN,CAAkBF,KAAK,CAACC,MAAxB,CAAf,GAAiDD,KAAK,CAACG,aAAN,IAAuB,IAAtF;IACA,KAAKC,MAAL,GAAcJ,KAAK,CAACI,MAAN,GAAelB,KAAK,CAACgB,WAAN,CAAkBF,KAAK,CAACI,MAAxB,CAAf,GAAiDJ,KAAK,CAACK,aAAN,IAAuB,IAAtF;IAEA,KAAKC,eAAL,GAAuBN,KAAK,CAACM,eAAN,GAAwBN,KAAK,CAACM,eAA9B,GAAgDN,KAAK,CAACM,eAAN,IAAyB,GAAhG;IAEA,KAAKC,cAAL,GAAsBP,KAAK,CAACQ,cAAN,GAAuB,EAAvB,GAA4BR,KAAK,CAACO,cAAN,IAAwB,GAA1E;IACA,KAAKC,cAAL,GAAsB,KAAKD,cAAL,GAAsB,EAAtB,GAA2BP,KAAK,CAACQ,cAAN,IAAwB,EAAzE;IAEA,KAAKC,aAAL,GAAqBT,KAAK,CAACS,aAAN,GAAsBvB,KAAK,CAACgB,WAAN,CAAkBF,KAAK,CAACS,aAAxB,CAAtB,GAA+DT,KAAK,CAACU,oBAAN,IAA8BxB,KAAK,CAACgB,WAAN,CAAkB,KAAlB,CAAlH;IACA,KAAKS,aAAL,GAAqBX,KAAK,CAACW,aAAN,GAAsBzB,KAAK,CAACgB,WAAN,CAAkBF,KAAK,CAACW,aAAxB,CAAtB,GAA+DX,KAAK,CAACY,oBAAN,IAA8B1B,KAAK,CAACgB,WAAN,CAAkB,GAAlB,CAAlH;IAEA,KAAKW,WAAL,GAAmBb,KAAK,CAACa,WAAN,GAAoBb,KAAK,CAACa,WAA1B,GAAwC,IAA3D,CA5B4C,CA8B5C;;IACA,KAAKC,WAAL;EACD,CAhCD;;EAkCA1B,YAAY,CAACT,SAAb,CAAuBe,KAAvB,GAA+B,SAASA,KAAT,GAAiB;IAC9C,IAAI,KAAKL,OAAT,EAAkB,KAAKI,IAAL,CAAU,KAAKJ,OAAf;EACnB,CAFD;;EAIAD,YAAY,CAACT,SAAb,CAAuBmC,WAAvB,GAAqC,SAASA,WAAT,GAAuB;IAC1D;IACA,IAAIC,SAAS,GAAG,KAAKd,MAAL,GAAc,OAAd,GAAwB,KAAKG,MAA7C;IACA,KAAKY,MAAL,GAAc,IAAIC,MAAJ,CAAWF,SAAX,EAAsB,GAAtB,CAAd;IAEA,IAAIG,iBAAiB,GAAG,KAAK,KAAKjB,MAAV,GAAmB,KAAKM,cAAxB,GAAyC,OAAzC,GAAmD,KAAKC,cAAxD,GAAyE,KAAKJ,MAAtG;IACA,KAAKe,cAAL,GAAsB,IAAIF,MAAJ,CAAWC,iBAAX,EAA8B,GAA9B,CAAtB;IAEA,IAAIE,gBAAgB,GAAG,KAAKX,aAAL,GAAqB,OAArB,GAA+B,KAAKE,aAA3D;IACA,KAAKU,aAAL,GAAqB,IAAIJ,MAAJ,CAAWG,gBAAX,EAA6B,GAA7B,CAArB;EACD,CAVD;;EAYAhC,YAAY,CAACT,SAAb,CAAuB2C,WAAvB,GAAqC,SAASA,WAAT,CAAqBC,GAArB,EAA0BC,IAA1B,EAAgCC,GAAhC,EAAqC;IACxE,IAAIC,KAAK,GAAG,IAAZ;;IAEA,IAAIC,KAAK,GAAG,KAAK,CAAjB;IACA,IAAI9B,KAAK,GAAG,KAAK,CAAjB;IACA,IAAI+B,QAAQ,GAAG,KAAK,CAApB;;IAEA,SAASC,SAAT,CAAmBC,GAAnB,EAAwB;MACtB,OAAOA,GAAG,CAACC,OAAJ,CAAY,KAAZ,EAAmB,MAAnB,CAAP;IACD;;IAED,IAAIC,YAAY,GAAG,SAASA,YAAT,CAAsBtD,GAAtB,EAA2B;MAC5C,IAAIA,GAAG,CAACuD,OAAJ,CAAYP,KAAK,CAACpB,eAAlB,IAAqC,CAAzC,EAA4C,OAAOpB,KAAK,CAACgD,OAAN,CAAcV,IAAd,EAAoB9C,GAApB,CAAP;MAE5C,IAAIyD,CAAC,GAAGzD,GAAG,CAAC0D,KAAJ,CAAUV,KAAK,CAACpB,eAAhB,CAAR;MACA,IAAI+B,CAAC,GAAGF,CAAC,CAACG,KAAF,GAAUC,IAAV,EAAR;MACA,IAAIC,CAAC,GAAGL,CAAC,CAACM,IAAF,CAAOf,KAAK,CAACpB,eAAb,EAA8BiC,IAA9B,EAAR;MAEA,OAAOb,KAAK,CAAC/B,MAAN,CAAaT,KAAK,CAACgD,OAAN,CAAcV,IAAd,EAAoBa,CAApB,CAAb,EAAqCG,CAArC,EAAwCf,GAAxC,CAAP;IACD,CARD;;IAUA,KAAKX,WAAL;IAEAc,QAAQ,GAAG,CAAX,CAvBwE,CAwBxE;;IACA;;IACA,OAAOD,KAAK,GAAG,KAAKR,cAAL,CAAoBuB,IAApB,CAAyBnB,GAAzB,CAAf,EAA8C;MAC5C1B,KAAK,GAAGmC,YAAY,CAACL,KAAK,CAAC,CAAD,CAAL,CAASY,IAAT,EAAD,CAApB;MACAhB,GAAG,GAAGA,GAAG,CAACQ,OAAJ,CAAYJ,KAAK,CAAC,CAAD,CAAjB,EAAsB9B,KAAtB,CAAN;MACA,KAAKsB,cAAL,CAAoBwB,SAApB,GAAgC,CAAhC;MACAf,QAAQ;;MACR,IAAIA,QAAQ,IAAI,KAAKf,WAArB,EAAkC;QAChC;MACD;IACF;;IAEDe,QAAQ,GAAG,CAAX,CApCwE,CAqCxE;;IACA,OAAOD,KAAK,GAAG,KAAKX,MAAL,CAAY0B,IAAZ,CAAiBnB,GAAjB,CAAf,EAAsC;MACpC1B,KAAK,GAAGmC,YAAY,CAACL,KAAK,CAAC,CAAD,CAAL,CAASY,IAAT,EAAD,CAApB;MACA,IAAI,OAAO1C,KAAP,KAAiB,QAArB,EAA+BA,KAAK,GAAGX,KAAK,CAAC0D,UAAN,CAAiB/C,KAAjB,CAAR;;MAC/B,IAAI,CAACA,KAAL,EAAY;QACV,IAAI,OAAO,KAAKR,OAAL,CAAawD,2BAApB,KAAoD,UAAxD,EAAoE;UAClE,IAAIC,IAAI,GAAG,KAAKzD,OAAL,CAAawD,2BAAb,CAAyCtB,GAAzC,EAA8CI,KAA9C,CAAX;UACA9B,KAAK,GAAG,OAAOiD,IAAP,KAAgB,QAAhB,GAA2BA,IAA3B,GAAkC,EAA1C;QACD,CAHD,MAGO;UACL,KAAKvD,MAAL,CAAYwD,IAAZ,CAAiB,gCAAgCpB,KAAK,CAAC,CAAD,CAArC,GAA2C,qBAA3C,GAAmEJ,GAApF;UACA1B,KAAK,GAAG,EAAR;QACD;MACF;;MACDA,KAAK,GAAG,KAAKE,WAAL,GAAmB8B,SAAS,CAAC,KAAK/B,MAAL,CAAYD,KAAZ,CAAD,CAA5B,GAAmDgC,SAAS,CAAChC,KAAD,CAApE;MACA0B,GAAG,GAAGA,GAAG,CAACQ,OAAJ,CAAYJ,KAAK,CAAC,CAAD,CAAjB,EAAsB9B,KAAtB,CAAN;MACA,KAAKmB,MAAL,CAAY2B,SAAZ,GAAwB,CAAxB;MACAf,QAAQ;;MACR,IAAIA,QAAQ,IAAI,KAAKf,WAArB,EAAkC;QAChC;MACD;IACF;;IACD,OAAOU,GAAP;EACD,CA3DD;;EA6DAnC,YAAY,CAACT,SAAb,CAAuBqE,IAAvB,GAA8B,SAASA,IAAT,CAAczB,GAAd,EAAmB0B,EAAnB,EAAuB;IACnD,IAAI5D,OAAO,GAAGd,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBe,SAAzC,GAAqDf,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;IAEA,IAAIoD,KAAK,GAAG,KAAK,CAAjB;IACA,IAAI9B,KAAK,GAAG,KAAK,CAAjB;;IAEA,IAAIqD,aAAa,GAAGhF,QAAQ,CAAC,EAAD,EAAKmB,OAAL,CAA5B;;IACA6D,aAAa,CAACC,kBAAd,GAAmC,KAAnC,CAPmD,CAOT;IAE1C;;IACA,SAASC,gBAAT,CAA0B1E,GAA1B,EAA+B2E,gBAA/B,EAAiD;MAC/C,IAAI3E,GAAG,CAACuD,OAAJ,CAAY,GAAZ,IAAmB,CAAvB,EAA0B,OAAOvD,GAAP;MAE1B,IAAIyD,CAAC,GAAGzD,GAAG,CAAC0D,KAAJ,CAAU,GAAV,CAAR;MACA1D,GAAG,GAAGyD,CAAC,CAACG,KAAF,EAAN;MACA,IAAIgB,aAAa,GAAGnB,CAAC,CAACM,IAAF,CAAO,GAAP,CAApB;MACAa,aAAa,GAAG,KAAKhC,WAAL,CAAiBgC,aAAjB,EAAgCJ,aAAhC,CAAhB;MACAI,aAAa,GAAGA,aAAa,CAACvB,OAAd,CAAsB,IAAtB,EAA4B,GAA5B,CAAhB;;MAEA,IAAI;QACFmB,aAAa,GAAGK,IAAI,CAACC,KAAL,CAAWF,aAAX,CAAhB;QAEA,IAAID,gBAAJ,EAAsBH,aAAa,GAAGhF,QAAQ,CAAC,EAAD,EAAKmF,gBAAL,EAAuBH,aAAvB,CAAxB;MACvB,CAJD,CAIE,OAAOO,CAAP,EAAU;QACV,KAAKlE,MAAL,CAAYmE,KAAZ,CAAkB,sDAAsDhF,GAAxE,EAA6E+E,CAA7E;MACD;;MAED,OAAO/E,GAAP;IACD,CA5BkD,CA8BnD;;;IACA,OAAOiD,KAAK,GAAG,KAAKN,aAAL,CAAmBqB,IAAnB,CAAwBnB,GAAxB,CAAf,EAA6C;MAC3C1B,KAAK,GAAGoD,EAAE,CAACG,gBAAgB,CAACvE,IAAjB,CAAsB,IAAtB,EAA4B8C,KAAK,CAAC,CAAD,CAAL,CAASY,IAAT,EAA5B,EAA6CW,aAA7C,CAAD,EAA8DA,aAA9D,CAAV,CAD2C,CAG3C;;MACA,IAAIrD,KAAK,IAAI8B,KAAK,CAAC,CAAD,CAAL,KAAaJ,GAAtB,IAA6B,OAAO1B,KAAP,KAAiB,QAAlD,EAA4D,OAAOA,KAAP,CAJjB,CAM3C;;MACA,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+BA,KAAK,GAAGX,KAAK,CAAC0D,UAAN,CAAiB/C,KAAjB,CAAR;;MAC/B,IAAI,CAACA,KAAL,EAAY;QACV,KAAKN,MAAL,CAAYwD,IAAZ,CAAiB,uBAAuBpB,KAAK,CAAC,CAAD,CAA5B,GAAkC,eAAlC,GAAoDJ,GAArE;QACA1B,KAAK,GAAG,EAAR;MACD,CAX0C,CAY3C;MACA;;;MACA0B,GAAG,GAAGA,GAAG,CAACQ,OAAJ,CAAYJ,KAAK,CAAC,CAAD,CAAjB,EAAsB9B,KAAtB,CAAN;MACA,KAAKmB,MAAL,CAAY2B,SAAZ,GAAwB,CAAxB;IACD;;IACD,OAAOpB,GAAP;EACD,CAjDD;;EAmDA,OAAOnC,YAAP;AACD,CAjLkB,EAAnB;;AAmLA,eAAeA,YAAf"},"metadata":{},"sourceType":"module"}