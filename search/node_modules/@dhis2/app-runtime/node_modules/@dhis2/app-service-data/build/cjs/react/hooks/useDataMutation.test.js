"use strict";

var _reactHooks = require("@testing-library/react-hooks");

var React = _interopRequireWildcard(require("react"));

var _CustomDataProvider = require("../components/CustomDataProvider");

var _useDataEngine = require("./useDataEngine");

var _useDataMutation = require("./useDataMutation");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

describe('useDataMutation', () => {
  it('should render without failing', async () => {
    const mutation = {
      type: 'create',
      resource: 'answer',
      data: {
        answer: '?'
      }
    };
    const data = {
      answer: 42
    };

    const wrapper = ({
      children
    }) => /*#__PURE__*/React.createElement(_CustomDataProvider.CustomDataProvider, {
      data: data
    }, children);

    const {
      result,
      waitFor
    } = (0, _reactHooks.renderHook)(() => (0, _useDataMutation.useDataMutation)(mutation), {
      wrapper
    });
    const [mutate, beforeMutation] = result.current;
    expect(beforeMutation).toMatchObject({
      loading: false,
      called: false
    });
    (0, _reactHooks.act)(() => {
      mutate();
    });
    await waitFor(() => {
      const [, duringMutation] = result.current;
      expect(duringMutation).toMatchObject({
        loading: true,
        called: true
      });
    });
    await waitFor(() => {
      const [, afterMutation] = result.current;
      expect(afterMutation).toMatchObject({
        loading: false,
        called: true,
        data: 42
      });
    });
  });
  it('should run immediately with lazy: false', async () => {
    const mutation = {
      type: 'create',
      resource: 'answer',
      data: {
        answer: '?'
      }
    };
    const data = {
      answer: 42
    };

    const wrapper = ({
      children
    }) => /*#__PURE__*/React.createElement(_CustomDataProvider.CustomDataProvider, {
      data: data
    }, children);

    const {
      result,
      waitFor
    } = (0, _reactHooks.renderHook)(() => (0, _useDataMutation.useDataMutation)(mutation, {
      lazy: false
    }), {
      wrapper
    });
    const [, duringMutation] = result.current;
    expect(duringMutation).toMatchObject({
      loading: true,
      called: true
    });
    await waitFor(() => {
      const [, afterMutation] = result.current;
      expect(afterMutation).toMatchObject({
        loading: false,
        called: true,
        data: 42
      });
    });
  });
  it('should call onComplete on success', async () => {
    const onComplete = jest.fn();
    const mutation = {
      type: 'create',
      resource: 'answer',
      data: {
        answer: '?'
      }
    };
    const data = {
      answer: 42
    };

    const wrapper = ({
      children
    }) => /*#__PURE__*/React.createElement(_CustomDataProvider.CustomDataProvider, {
      data: data
    }, children);

    const {
      result,
      waitFor
    } = (0, _reactHooks.renderHook)(() => (0, _useDataMutation.useDataMutation)(mutation, {
      onComplete
    }), {
      wrapper
    });
    expect(onComplete).toHaveBeenCalledTimes(0);
    const [mutate] = result.current;
    (0, _reactHooks.act)(() => {
      mutate();
    });
    await waitFor(() => {
      const [, state] = result.current;
      expect(state).toMatchObject({
        loading: false,
        called: true,
        data: 42
      });
      expect(onComplete).toHaveBeenCalledTimes(1);
      expect(onComplete).toHaveBeenLastCalledWith(42);
    });
  });
  it('should call onError on error', async () => {
    const error = new Error('Something went wrong');
    const onError = jest.fn();
    const mutation = {
      type: 'create',
      resource: 'answer',
      data: {
        answer: 42
      }
    };
    const data = {
      answer: () => {
        throw error;
      }
    };

    const wrapper = ({
      children
    }) => /*#__PURE__*/React.createElement(_CustomDataProvider.CustomDataProvider, {
      data: data
    }, children);

    const {
      result,
      waitFor
    } = (0, _reactHooks.renderHook)(() => (0, _useDataMutation.useDataMutation)(mutation, {
      onError
    }), {
      wrapper
    });
    expect(onError).toHaveBeenCalledTimes(0);
    const [mutate] = result.current;
    (0, _reactHooks.act)(() => {
      mutate();
    });
    await waitFor(() => {
      const [, state] = result.current;
      expect(state).toMatchObject({
        loading: false,
        called: true,
        error
      });
    });
    expect(onError).toHaveBeenCalledTimes(1);
    expect(onError).toHaveBeenLastCalledWith(error);
  });
  it('should resolve variables', async () => {
    const mutation = {
      type: 'update',
      resource: 'answer',
      id: ({
        id
      }) => id,
      data: {
        answer: '?'
      }
    };
    const answerSpy = jest.fn(() => 42);
    const data = {
      answer: answerSpy
    };

    const wrapper = ({
      children
    }) => /*#__PURE__*/React.createElement(_CustomDataProvider.CustomDataProvider, {
      data: data
    }, children);

    const {
      result,
      waitFor
    } = (0, _reactHooks.renderHook)(() => (0, _useDataMutation.useDataMutation)(mutation, {
      lazy: false,
      variables: {
        id: '1'
      }
    }), {
      wrapper
    });
    await waitFor(() => {
      expect(answerSpy).toHaveBeenLastCalledWith(expect.any(String), expect.objectContaining({
        id: '1'
      }), expect.any(Object));
    });
    const [mutate] = result.current;
    (0, _reactHooks.act)(() => {
      mutate({
        id: '2'
      });
    });
    await waitFor(() => {
      expect(answerSpy).toHaveBeenLastCalledWith(expect.any(String), expect.objectContaining({
        id: '2'
      }), expect.any(Object));
    });
  });
  it('should return a reference to the engine', async () => {
    const mutation = {
      type: 'create',
      resource: 'answer',
      data: {
        answer: '?'
      }
    };

    const wrapper = ({
      children
    }) => /*#__PURE__*/React.createElement(_CustomDataProvider.CustomDataProvider, {
      data: {}
    }, children);

    const engineHook = (0, _reactHooks.renderHook)(() => (0, _useDataEngine.useDataEngine)(), {
      wrapper
    });
    const mutationHook = (0, _reactHooks.renderHook)(() => (0, _useDataMutation.useDataMutation)(mutation), {
      wrapper
    });
    /**
     * Ideally we'd check referential equality here with .toBe, but since
     * both hooks run in a different context that doesn't work.
     */

    expect(mutationHook.result.current[1].engine).toStrictEqual(engineHook.result.current);
  });
  it('should return a stable mutate function', async () => {
    const mutation = {
      type: 'create',
      resource: 'answer',
      data: {
        answer: '?'
      }
    };
    const data = {
      answer: 42
    };

    const wrapper = ({
      children
    }) => /*#__PURE__*/React.createElement(_CustomDataProvider.CustomDataProvider, {
      data: data
    }, children);

    const {
      result
    } = (0, _reactHooks.renderHook)(() => (0, _useDataMutation.useDataMutation)(mutation), {
      wrapper
    });
    const [firstMutate] = result.current;
    await (0, _reactHooks.act)(async () => {
      await firstMutate({
        variable: 'variable'
      });
    });
    const [secondMutate, state] = result.current;
    expect(state).toMatchObject({
      loading: false,
      called: true
    });
    expect(firstMutate).toBe(secondMutate);
  });
  it('should resolve with the data from mutate on success', async () => {
    const mutation = {
      type: 'create',
      resource: 'answer',
      data: {
        answer: '?'
      }
    };
    const data = {
      answer: 42
    };

    const wrapper = ({
      children
    }) => /*#__PURE__*/React.createElement(_CustomDataProvider.CustomDataProvider, {
      data: data
    }, children);

    const {
      result,
      waitFor
    } = (0, _reactHooks.renderHook)(() => (0, _useDataMutation.useDataMutation)(mutation), {
      wrapper
    });
    let mutatePromise;
    const [mutate] = result.current;
    (0, _reactHooks.act)(() => {
      mutatePromise = mutate();
    });
    await waitFor(() => {
      const [, state] = result.current;
      expect(state).toMatchObject({
        loading: false,
        called: true,
        data: 42
      });
      expect(mutatePromise).resolves.toBe(42);
    });
  });
});