"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDataQuery = void 0;

var _react = require("react");

var _reactQuery = require("react-query");

var _mergeAndCompareVariables = require("./mergeAndCompareVariables");

var _useDataEngine = require("./useDataEngine");

var _useStaticInput = require("./useStaticInput");

const noop = () => {
  /**
   * Used to silence the default react-query logger. Eventually we
   * could expose the setLogger functionality and remove the call
   * to setLogger here.
   */
};

(0, _reactQuery.setLogger)({
  log: noop,
  warn: noop,
  error: noop
});

const useDataQuery = (query, {
  onComplete: userOnSuccess,
  onError: userOnError,
  variables: initialVariables = {},
  lazy: initialLazy = false
} = {}) => {
  const [staticQuery] = (0, _useStaticInput.useStaticInput)(query, {
    warn: true,
    name: 'query'
  });
  const [variablesUpdateCount, setVariablesUpdateCount] = (0, _react.useState)(0);
  const queryState = (0, _react.useRef)({
    variables: initialVariables,
    variablesHash: undefined,
    enabled: !initialLazy,
    refetchCallback: undefined
  });
  /**
   * Display current query state and refetch count in React DevTools
   */

  (0, _react.useDebugValue)({
    variablesUpdateCount,
    enabled: queryState.current.enabled,
    variables: queryState.current.variables
  }, debugValue => JSON.stringify(debugValue));
  /**
   * User callbacks and refetch handling
   */

  const onSuccess = data => {
    var _queryState$current$r, _queryState$current;

    (_queryState$current$r = (_queryState$current = queryState.current).refetchCallback) === null || _queryState$current$r === void 0 ? void 0 : _queryState$current$r.call(_queryState$current, data);
    queryState.current.refetchCallback = undefined;

    if (userOnSuccess) {
      userOnSuccess(data);
    }
  };

  const onError = error => {
    // If we'd want to reject on errors we'd call the cb with the error here
    queryState.current.refetchCallback = undefined;

    if (userOnError) {
      userOnError(error);
    }
  };
  /**
   * Setting up react-query
   */


  const engine = (0, _useDataEngine.useDataEngine)();
  const queryKey = [staticQuery, queryState.current.variables];

  const queryFn = () => engine.query(staticQuery, {
    variables: queryState.current.variables
  });

  const {
    isIdle,
    isFetching,
    isLoading,
    error,
    data,
    refetch: queryRefetch
  } = (0, _reactQuery.useQuery)(queryKey, queryFn, {
    enabled: queryState.current.enabled,
    onSuccess,
    onError
  });
  /**
   * Refetch allows a user to update the variables or just
   * trigger a refetch of the query with the current variables.
   *
   * We're using useCallback to make the identity of the function
   * as stable as possible, so that it won't trigger excessive
   * rerenders when used for side-effects.
   */

  const refetch = (0, _react.useCallback)(newVariables => {
    const {
      identical,
      mergedVariables,
      mergedVariablesHash
    } = (0, _mergeAndCompareVariables.mergeAndCompareVariables)(queryState.current.variables, newVariables, queryState.current.variablesHash);
    /**
     * If there are no updates that will trigger an automatic refetch
     * we'll need to call react-query's refetch directly
     */

    if (queryState.current.enabled && identical) {
      return queryRefetch({
        cancelRefetch: true,
        throwOnError: false
      }).then(({
        data
      }) => data);
    }

    queryState.current.variables = mergedVariables;
    queryState.current.variablesHash = mergedVariablesHash;
    queryState.current.enabled = true; // This promise does not currently reject on errors

    const refetchPromise = new Promise(resolve => {
      queryState.current.refetchCallback = data => {
        resolve(data);
      };
    }); // Trigger a react-query refetch by incrementing variablesUpdateCount state

    setVariablesUpdateCount(prevCount => prevCount + 1);
    return refetchPromise;
  }, [queryRefetch]);
  /**
   * react-query returns null or an error, but we return undefined
   * or an error, so this ensures consistency with the other types.
   */

  const ourError = error || undefined;
  return {
    engine,
    // A query is idle if it is lazy and no initial data is available.
    called: !isIdle,
    loading: isLoading,
    fetching: isFetching,
    error: ourError,
    data,
    refetch
  };
};

exports.useDataQuery = useDataQuery;