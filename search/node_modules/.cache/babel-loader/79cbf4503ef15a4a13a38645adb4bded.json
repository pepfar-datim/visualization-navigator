{"ast":null,"code":"import PropTypes from 'prop-types';\nimport React, { useEffect } from 'react';\nimport { useRecordingState, useCachedSection } from './cacheable-section-state';\nimport { useOfflineInterface } from './offline-interface';\nvar recordingStates = {\n  default: 'default',\n  pending: 'pending',\n  recording: 'recording',\n  error: 'error'\n};\n/**\n * Returns the main controls for a cacheable section and manages recording\n * state, which affects the render state of the CacheableSection component.\n * Also returns the cached status of the section, which come straight from\n * the `useCachedSection` hook.\n *\n * @param {String} id\n * @returns {Object}\n */\n\nexport function useCacheableSection(id) {\n  var offlineInterface = useOfflineInterface();\n\n  var _useCachedSection = useCachedSection(id),\n      isCached = _useCachedSection.isCached,\n      lastUpdated = _useCachedSection.lastUpdated,\n      remove = _useCachedSection.remove,\n      syncCachedSections = _useCachedSection.syncCachedSections;\n\n  var _useRecordingState = useRecordingState(id),\n      recordingState = _useRecordingState.recordingState,\n      setRecordingState = _useRecordingState.setRecordingState,\n      removeRecordingState = _useRecordingState.removeRecordingState;\n\n  useEffect(function () {\n    // On mount, add recording state for this ID to context if needed\n    if (!recordingState) {\n      setRecordingState(recordingStates.default);\n    } // On unnmount, remove recording state if not recording\n\n\n    return function () {\n      if (recordingState && recordingState !== recordingStates.recording && recordingState !== recordingStates.pending) {\n        removeRecordingState();\n      }\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  function startRecording() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$recordingTimeout = _ref.recordingTimeoutDelay,\n        recordingTimeoutDelay = _ref$recordingTimeout === void 0 ? 1000 : _ref$recordingTimeout,\n        _onStarted = _ref.onStarted,\n        _onCompleted = _ref.onCompleted,\n        _onError = _ref.onError;\n\n    // This promise resolving means that the message to the service worker\n    // to start recording was successful. Waiting for resolution prevents\n    // unnecessarily rerendering the whole component in case of an error\n    return offlineInterface.startRecording({\n      sectionId: id,\n      recordingTimeoutDelay: recordingTimeoutDelay,\n      onStarted: function onStarted() {\n        onRecordingStarted();\n        _onStarted && _onStarted();\n      },\n      onCompleted: function onCompleted() {\n        onRecordingCompleted();\n        _onCompleted && _onCompleted();\n      },\n      onError: function onError(error) {\n        onRecordingError(error);\n        _onError && _onError(error);\n      }\n    }).then(function () {\n      return setRecordingState(recordingStates.pending);\n    });\n  }\n\n  function onRecordingStarted() {\n    setRecordingState(recordingStates.recording);\n  }\n\n  function onRecordingCompleted() {\n    setRecordingState(recordingStates.default);\n    syncCachedSections();\n  }\n\n  function onRecordingError(error) {\n    console.error('Error during recording:', error);\n    setRecordingState(recordingStates.error);\n  } // isCached, lastUpdated, remove: _could_ be accessed by useCachedSection,\n  // but provided through this hook for convenience\n\n\n  return {\n    recordingState: recordingState,\n    startRecording: startRecording,\n    lastUpdated: lastUpdated,\n    isCached: isCached,\n    remove: remove\n  };\n}\n/**\n * Used to wrap the relevant component to be recorded and saved offline.\n * Depending on the recording state of the section, this wrapper will\n * render its children, not render its children while recording is pending,\n * or RErerender the chilren to force data fetching to record by the service\n * worker.\n *\n * During recording, a loading mask provided by props is also rendered that is\n * intended to prevent other interaction with the app that might interfere\n * with the recording process.\n */\n\nexport function CacheableSection(_ref2) {\n  var id = _ref2.id,\n      loadingMask = _ref2.loadingMask,\n      children = _ref2.children;\n\n  // Accesses recording state that useCacheableSection controls\n  var _useRecordingState2 = useRecordingState(id),\n      recordingState = _useRecordingState2.recordingState; // The following causes the component to reload in the event of a recording\n  // error; the state will be cleared next time recording moves to pending.\n  // It fixes a component getting stuck while rendered without data after\n  // failing a recording while offline.\n  // Errors can be handled in the `onError` callback to `startRecording`.\n\n\n  if (recordingState === recordingStates.error) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n  } // Handling rendering with the following conditions prevents an unncessary\n  // rerender after successful recording\n\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, recordingState === recordingStates.recording && loadingMask, recordingState !== recordingStates.pending && children);\n}\nCacheableSection.propTypes = {\n  id: PropTypes.string.isRequired,\n  children: PropTypes.node,\n  loadingMask: PropTypes.node\n};","map":{"version":3,"names":["PropTypes","React","useEffect","useRecordingState","useCachedSection","useOfflineInterface","recordingStates","default","pending","recording","error","useCacheableSection","id","offlineInterface","isCached","lastUpdated","remove","syncCachedSections","recordingState","setRecordingState","removeRecordingState","startRecording","recordingTimeoutDelay","onStarted","onCompleted","onError","sectionId","onRecordingStarted","onRecordingCompleted","onRecordingError","then","console","CacheableSection","loadingMask","children","createElement","Fragment","propTypes","string","isRequired","node"],"sources":["/home/jake/SRC/visualization-navigator-ts/node_modules/@dhis2/app-runtime/node_modules/@dhis2/app-service-offline/build/es/lib/cacheable-section.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React, { useEffect } from 'react';\nimport { useRecordingState, useCachedSection } from './cacheable-section-state';\nimport { useOfflineInterface } from './offline-interface';\nconst recordingStates = {\n  default: 'default',\n  pending: 'pending',\n  recording: 'recording',\n  error: 'error'\n};\n\n/**\n * Returns the main controls for a cacheable section and manages recording\n * state, which affects the render state of the CacheableSection component.\n * Also returns the cached status of the section, which come straight from\n * the `useCachedSection` hook.\n *\n * @param {String} id\n * @returns {Object}\n */\nexport function useCacheableSection(id) {\n  const offlineInterface = useOfflineInterface();\n  const {\n    isCached,\n    lastUpdated,\n    remove,\n    syncCachedSections\n  } = useCachedSection(id);\n  const {\n    recordingState,\n    setRecordingState,\n    removeRecordingState\n  } = useRecordingState(id);\n  useEffect(() => {\n    // On mount, add recording state for this ID to context if needed\n    if (!recordingState) {\n      setRecordingState(recordingStates.default);\n    } // On unnmount, remove recording state if not recording\n\n\n    return () => {\n      if (recordingState && recordingState !== recordingStates.recording && recordingState !== recordingStates.pending) {\n        removeRecordingState();\n      }\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  function startRecording({\n    recordingTimeoutDelay = 1000,\n    onStarted,\n    onCompleted,\n    onError\n  } = {}) {\n    // This promise resolving means that the message to the service worker\n    // to start recording was successful. Waiting for resolution prevents\n    // unnecessarily rerendering the whole component in case of an error\n    return offlineInterface.startRecording({\n      sectionId: id,\n      recordingTimeoutDelay,\n      onStarted: () => {\n        onRecordingStarted();\n        onStarted && onStarted();\n      },\n      onCompleted: () => {\n        onRecordingCompleted();\n        onCompleted && onCompleted();\n      },\n      onError: error => {\n        onRecordingError(error);\n        onError && onError(error);\n      }\n    }).then(() => setRecordingState(recordingStates.pending));\n  }\n\n  function onRecordingStarted() {\n    setRecordingState(recordingStates.recording);\n  }\n\n  function onRecordingCompleted() {\n    setRecordingState(recordingStates.default);\n    syncCachedSections();\n  }\n\n  function onRecordingError(error) {\n    console.error('Error during recording:', error);\n    setRecordingState(recordingStates.error);\n  } // isCached, lastUpdated, remove: _could_ be accessed by useCachedSection,\n  // but provided through this hook for convenience\n\n\n  return {\n    recordingState,\n    startRecording,\n    lastUpdated,\n    isCached,\n    remove\n  };\n}\n\n/**\n * Used to wrap the relevant component to be recorded and saved offline.\n * Depending on the recording state of the section, this wrapper will\n * render its children, not render its children while recording is pending,\n * or RErerender the chilren to force data fetching to record by the service\n * worker.\n *\n * During recording, a loading mask provided by props is also rendered that is\n * intended to prevent other interaction with the app that might interfere\n * with the recording process.\n */\nexport function CacheableSection({\n  id,\n  loadingMask,\n  children\n}) {\n  // Accesses recording state that useCacheableSection controls\n  const {\n    recordingState\n  } = useRecordingState(id); // The following causes the component to reload in the event of a recording\n  // error; the state will be cleared next time recording moves to pending.\n  // It fixes a component getting stuck while rendered without data after\n  // failing a recording while offline.\n  // Errors can be handled in the `onError` callback to `startRecording`.\n\n  if (recordingState === recordingStates.error) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n  } // Handling rendering with the following conditions prevents an unncessary\n  // rerender after successful recording\n\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, recordingState === recordingStates.recording && loadingMask, recordingState !== recordingStates.pending && children);\n}\nCacheableSection.propTypes = {\n  id: PropTypes.string.isRequired,\n  children: PropTypes.node,\n  loadingMask: PropTypes.node\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}